<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://richardtaocong.github.io/RichardTao.github.io</id>
    <title>RichardTao</title>
    <updated>2020-03-25T11:56:47.873Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://richardtaocong.github.io/RichardTao.github.io"/>
    <link rel="self" href="https://richardtaocong.github.io/RichardTao.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://richardtaocong.github.io/RichardTao.github.io/images/avatar.png</logo>
    <icon>https://richardtaocong.github.io/RichardTao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, RichardTao</rights>
    <entry>
        <title type="html"><![CDATA[前端全栈学习笔记]]></title>
        <id>https://richardtaocong.github.io/RichardTao.github.io/post/qian-duan-quan-zhan-xue-xi-bi-ji/</id>
        <link href="https://richardtaocong.github.io/RichardTao.github.io/post/qian-duan-quan-zhan-xue-xi-bi-ji/">
        </link>
        <updated>2020-03-25T11:40:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-babel">1. Babel</h1>
<blockquote>
<p>解决IE10以下浏览器及其他的不兼容ES6的问题，因此通过该插件将ES6的语法转换为浏览器可兼容理解的形式</p>
</blockquote>
<h2 id="11-步骤">1.1 步骤</h2>
<ul>
<li>
<p>在cmd中跳转到指定的工程目录下，使用npm命令下载babel相关的包：<code>npm i @babel/core @babel/cli @babel/preset-env -D</code></p>
</li>
<li>
<p>使用命令<code>npm init -y</code>创建一个名为 <code>package.json</code> 的文件，在该文件中配置相关信息：<code>&quot;build&quot;: &quot;babel src -d dest&quot;</code></p>
</li>
<li>
<p>之后需要新建两个文件夹： src文件夹存放的是需要转换格式的JS文件，dist文件夹存放的是转换之后的JS文件</p>
<ul>
<li>注意： 该方法要求所有的JS代码需要单独写到一个文件中</li>
</ul>
</li>
<li>
<p>再新建一个名为 <code>.babelrc</code>的文件，在里面指明转换JS文件预定义的格式（其实就是由babel提供的）：<code>{&quot;presets&quot;:[&quot;@babel/preset-env&quot;]}</code>，声明presets</p>
</li>
<li>
<p>最后在cmd中运行命令<code>npm run build</code>来运行我们之前在 <code>package.json</code> 文件中指定的build</p>
</li>
</ul>
<h1 id="2-闭包">2. 闭包</h1>
<blockquote>
<p>在ES6之后，使用到的场景大大减少，但需要注意面试中会经常问到</p>
</blockquote>
<h2 id="21-主要思想">2.1 主要思想</h2>
<ul>
<li>与语言的**垃圾回收(GC)**相关： 留着别删，对于正在使用的东西编译器不会回收</li>
</ul>
<h2 id="22-举例">2.2 举例</h2>
<pre><code class="language-javascript">window.onload = ()=&gt;{
    var input = document.getElementsByTagName(&quot;input&quot;);
    for(var i=0; i&lt;input.length; i++){
        (function(i){
            input[i].onclick = ()=&gt;{
            alert(i);
        }})(i);
    }
}
</code></pre>
<ul>
<li>闭包常常使用立即执行函数完成，故立即执行函数也成为小闭包</li>
</ul>
<h1 id="3-面向对象">3. 面向对象</h1>
<blockquote>
<p>ES6中对之前使用构造函数形式声明进行了标准的指定，统一使用类Class关键字来声明</p>
</blockquote>
<h2 id="31-发展历程">3.1 发展历程</h2>
<blockquote>
<p>机器语言 -&gt; 汇编语言 -&gt; 低级语言 -&gt; 高级语言 -&gt; 模块 -&gt; API</p>
</blockquote>
<h2 id="32-代码格式">3.2 代码格式</h2>
<pre><code class="language-javascript">class Person{
    constructor(name,age){
        this.name = name;
        this.age =age;
    }
    showMsg(){
        console.log(this.name,this.age);
    }
}
</code></pre>
<h2 id="33-包含部分">3.3 包含部分</h2>
<ul>
<li>
<p><code>class</code>关键字声明类</p>
</li>
<li>
<p>构造函数constructor声明，其中包含的是本类的属性</p>
</li>
<li>
<p>方法，直接写在类中即可，而不用再放在原型中</p>
</li>
</ul>
<h1 id="4-webpack">4. Webpack</h1>
<blockquote>
<p>具体内容在后续的<code>打包工具</code>一章介绍</p>
</blockquote>
<h2 id="41-简单介绍">4.1 简单介绍</h2>
<h3 id="411-注意事项">4.1.1 注意事项</h3>
<ol>
<li>
<p>entry： 声明入口地址</p>
</li>
<li>
<p>output： 输出；包含有：path为绝对地址，filename为文件名</p>
</li>
<li>
<p>mode： 模式，值包括 <code>production</code> 生产模式以及 <code>develop</code> 开发模式</p>
</li>
<li>
<p>所有当前的路径前要加'./'，这是 <code>node.js</code> 中的要求</p>
</li>
</ol>
<h3 id="412-export">4.1.2 export</h3>
<ul>
<li>
<p>可以导出变量、函数、类等等，只需要在他们之前加上一个 <code>export</code> 关键字</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre><code class="language-js">export let a = 15;

let b = &quot;name&quot;;
let d = 45;

export { b, d };

export function sum(a, b) {
    return a + b;
};

export class {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    showMsg() {
        console.log(name, age);
    }
}

//-最常用
export default 'abb';

// 从另一个模块导出
export * from './mod2';
export {a,b,c} from './mod3';
export {default} from './mod4';
</code></pre>
<h3 id="413-import">4.1.3 import</h3>
<ul>
<li>
<p>导入可以是目标文件中所有的变量、函数等；也可以是按需导入、只选择部分导入</p>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">//全部导入
import * as mod1 from './mod1';

//部分导入
import {a,b,d} from './mod1';

//导入默认成员-最常用
import xxx from './mod1';

//模块的代码引入进来，但不引入其中的成员，如css、图片文件
import &quot;1.css&quot;;
import &quot;a.jpg&quot;;

//异步引入,针对的是页面中次要的东西，如广告、抽奖等
//返回值是一个Promise
import(&quot;./mod2&quot;);
</code></pre>
<h1 id="5-nodejs">5. Node.js</h1>
<h2 id="51-介绍">5.1 介绍</h2>
<blockquote>
<p>Node.js是指用于服务器端的javascript，但是它一般不会用于独立开发服务器</p>
<p>模块管理工具<code>cmd</code>：<a href="https://github.com/seajs/seajs/issues/242">参考文档</a></p>
</blockquote>
<h3 id="511-用途">5.1.1 用途</h3>
<ul>
<li>
<p>中间层： Node.js是一个中间层的语言</p>
<ol>
<li>提高主服务器的安全性，不会将服务器直接暴露在外</li>
<li>提高性能，可以通过在中间层添加缓存、服务器分布等方式</li>
<li>降低主服务器的复杂度</li>
</ol>
<blockquote>
<p>中间层实际上也是服务器，与中间件截然不同</p>
</blockquote>
</li>
<li>
<p>小型服务</p>
</li>
<li>
<p>工具</p>
</li>
</ul>
<h3 id="512-优势">5.1.2 优势</h3>
<ul>
<li>便于前端人员快速入手</li>
<li>性能相对较高： 主要是指数据处理方面</li>
<li>利于和前端代码的整合
<ul>
<li>如前后台都要做<strong>数据的校验</strong>，在前台JS中有一套正则的校验程序，这时用node.js则只需要写一套代码即可，而不必重新再写一次</li>
</ul>
</li>
</ul>
<h3 id="513-服务器的功能">5.1.3 服务器的功能</h3>
<ul>
<li>处理客户端的请求</li>
<li>与前台数据的交互：可以调用预定义好的API</li>
<li>数据库操作</li>
</ul>
<h2 id="52-npm等包管理工具">5.2 npm等包管理工具</h2>
<blockquote>
<p><strong>node package manager</strong>： 为node.js做包管理使用的工具</p>
<p>它在下载安装一个新的包的时候可以<strong>自动解决依赖</strong>——即将相关的包也一并安装好</p>
</blockquote>
<h3 id="521-npm换源">5.2.1 npm换源</h3>
<pre><code class="language-js">//官网
https://npm.taobao.org/

//安装cnpm来代替npm
npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<h3 id="522-命令">5.2.2 命令</h3>
<ul>
<li>安装：<code>npm/cnpm install/i xxx</code></li>
<li>卸载：<code>npm/cnpm uninstall/un xxx</code></li>
</ul>
<blockquote>
<p>模块的安装中，还可以添加选项参数</p>
<p>-D： 表示<code>--save</code>运行生效</p>
<p>-S： 表示<code>--save dev</code>开发生效</p>
</blockquote>
<h3 id="523-其他包管理工具">5.2.3 其他包管理工具</h3>
<ul>
<li>
<p><code>npm</code>:   速度慢，包比较全</p>
</li>
<li>
<p><code>cnpm</code>： 目前最好用的，是企业使用的包管理工具，速度快，但是版本不是最新的</p>
<ul>
<li>
<blockquote>
<p>使用方法与<code>npm</code>一样</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>yarn</code>：已经逐渐被淘汰，速度慢</p>
<ul>
<li>
<blockquote>
<p>工具安装：<code>npm i yarn -g</code></p>
<p>使用命令：<code>yarn add xxx</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>bower</code>：主要用于前端包的管理</p>
<ul>
<li>
<blockquote>
<p>工具安装： <code>npm i bower -g</code></p>
<p>使用命令： <code>bower i bower</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="53-使用">5.3 使用</h2>
<h3 id="531-运行文件">5.3.1 运行文件</h3>
<ul>
<li>切换目录： 在 <code>cmd</code> 中切换到想要运行文件的当前目录下</li>
<li>直接运行： 使用命令 <code>node xxx.js</code>就可以运行该js文件了</li>
</ul>
<h3 id="532-使用其他的模块">5.3.2 使用其他的模块</h3>
<ul>
<li>安装： <code>cnpm i xxx</code></li>
<li>引入：在JS文件中将安装好的包引入进来，使用 <code>const multer = require('multer')</code></li>
<li>使用</li>
</ul>
<h2 id="54-常用模块包以及方法">5.4 常用模块/包以及方法</h2>
<h3 id="541-http模块">5.4.1 Http模块</h3>
<p>回调函数中有两个重要的对象参数： <code>response</code> 以及 <code>request</code>。</p>
<p>但是<strong>要注意</strong>：这两个对象在回调函数中的顺序是<code>request</code>在前</p>
<ul>
<li>response的两个方法</li>
</ul>
<pre><code class="language-js">//向客户端中写入内容
response.write(&quot;abc&quot;);

对于write()方法而言，是发送给页面还是传递给ajax回调函数，这取决于前台用户请求的方式：若是直接使用url来请求数据，那么就会发送到页面。

//主动断开连接
response.end();
</code></pre>
<ul>
<li>request中的方法与属性</li>
</ul>
<pre><code class="language-js">//请求用户的url
request.url;
</code></pre>
<ul>
<li>示例</li>
</ul>
<pre><code class="language-js">//引入模块
const http = require('http');

let server = http.createServer(()=&gt;{
    //回调函数
    //获取用户的请求url
    console.log(request.url);
    
    //向客户端中写入内容
	response.write(&quot;abc&quot;);
	//主动断开连接
	response.end();
});

//监听请求
server.listen(8080);
</code></pre>
<h3 id="542-文件fs模块">5.4.2 文件FS模块</h3>
<pre><code class="language-js">//1.写入文件
fs.writeFile(文件路径，写入数据，回调函数)
fs.writeFileSync(文件路径，写入数据，回调函数)

//示例
fs.writeFile('./write.txt','hello, this is my first string',(err)=&gt;{
    if(err){
        console.log(&quot;Error&quot;);
    }else{
        console.log(&quot;Success&quot;);
    }
});

---------------------------

//2.读取文件
fs.readFile(文件路径，回调函数)
fs.readFileSync(文件路径，回调函数)

//示例
fs.readFile('./write.txt',(err,data)=&gt;{
    if(err){
        console.log(&quot;Error&quot;,err);
    }else{
        //对于data直接打印时，是Buffer类型的数据---二进制
        console.log(&quot;Success&quot;,data.toString());
    }
});
</code></pre>
<blockquote>
<p>注意：在readFile方法中，我们直接输出数据data对象时，node默认输出的形式是<code>Buffer</code>类型的。若有需要，则需要通过<code>toString()</code>方法来转为String</p>
</blockquote>
<ul>
<li><strong>综合-小型服务器</strong></li>
</ul>
<pre><code class="language-js">const http = require('http');
const fs = require('fs');

let server = http.createServer((request,response)=&gt;{
    //打印用户请求的Url
    console.log(request.url);

    fs.readFile(`www${request.url}`,function(err,data){
        //失败
        if (err) {
            //以机器可理解的语言写入状态
            response.writeHeader(404);
            response.write(&quot;404 Not Found&quot;);
            response.end();
        }else{
            //将数据的原本形式-buffer 返回
            response.write(data);
            response.end();
        }
    });

});

//监听请求
server.listen(8080);
</code></pre>
<blockquote>
<p>在<code>response.writeHeader</code>方法中，传递的是状态码：</p>
<p>1xx：表示信息，使用的场景很少</p>
<p>2xx：成功</p>
<p>3xx：重定向</p>
<p>4xx：请求错误，是浏览器、客户端的错误</p>
<p>5xx：服务器错误</p>
</blockquote>
<hr>
<blockquote>
<p><strong>3、4为接收浏览器的get数据常用的模块</strong></p>
</blockquote>
<h3 id="543-querystring模块">5.4.3 QueryString模块</h3>
<blockquote>
<p>该模块专门用于处理get请求中的参数处理</p>
</blockquote>
<ul>
<li><code>queryString.parse()</code>方法：将传入字符串解析为<code>json对象</code></li>
<li><code>queryString.stringify()</code>方法：反向操作，将对象转为字符串</li>
</ul>
<pre><code class="language-js">/* 示例 */
const http = require('http');

console.log(queryString.parse('a=richard&amp;b=abc')); //{ a: 'richard', b: 'abc' }

//该模块专门用于处理get请求中的参数处理
const queryString = require('querystring');

let server = http.createServer((request,response)=&gt;{
    console.log(request.url);
    /*
    * 先分割字符串在使用parse方法解析
    */
    let [url,query] = request.url.split('?');
    //使用queryString中的parse方法将参数解析
    let get = queryString.parse(query);

    console.log(url,get);
});

server.listen(8080);
</code></pre>
<h3 id="544-url模块">5.4.4 Url模块</h3>
<blockquote>
<p>用于处理网址：解析、拼接等功能</p>
</blockquote>
<ul>
<li><code>url.parse(url数据，true|false)</code>：解析传入的url
<ul>
<li>第二个参数表示是否处理<code>query</code>即参数，<strong>true</strong>则将query字段转为json对象来处理</li>
</ul>
</li>
</ul>
<pre><code class="language-js">//示例
//专门处理url
const url = require('url');

let urlname = 'https://www.baidu.com:80/read/book/222.html?a=richard&amp;b=abc&amp;a=11';

console.log(url.parse(urlname,true));
</code></pre>
<h3 id="545-assert模块-特别常用">5.4.5 Assert模块-特别常用</h3>
<blockquote>
<p><code>assert</code>： <strong>断言</strong>。</p>
<p>简而言之：它主要应用与对函数的参数、API等进行严格测试，如果模块允许则让其通过，如果不允许那么就让其停止并报错</p>
</blockquote>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>在一个相对大的函数/模块中，可能会分为多个阶段，那么为了确保前一个阶段的结果正确而不导致影响到后续，可以在每个阶段之间添加<code>assert</code></li>
<li></li>
</ul>
<h4 id="使用">使用</h4>
<pre><code class="language-js">//模块引入
const assert = require('assert');

//一般的使用-最常用
assert(1&lt;3,'error: stu');

//深度的比较，它不仅比较值是否相等、同时会比较其成员。适合于json数据
assert.deepEqual(变量，预期值，msg);

//比deepEqual()更加严格，相当于'===',同时会比较成员的类型
assert.deepStrictEqual();
</code></pre>
<h3 id="545-path模块">5.4.5 Path模块</h3>
<blockquote>
<p>主要用于路径的解析，以及能够将中间的逻辑层路径整合成最后想要的结果</p>
</blockquote>
<h4 id="使用-2">使用</h4>
<pre><code class="language-js">const path = require('path');

let pathname = '/root/base/www/abc.txt';

//工作路径
console.log(path.dirname(pathname)); //输出/root/base/www
//请求资源名
console.log(path.basename(pathname)); //输出abc.txt
//文件后缀
console.log(path.extname(pathname)); //输出.txt

/*
* 常用的方法是：resolve---能够处理中间的混乱逻辑
*/
// E:\root\base\cooper\erotic
console.log(path.resolve('/root/base/www','../cooper','david','..','erotic'));

//用于输出某个绝对路径
//E:\Code\JS\Node\NodeTwo\build
console.log(path.resolve(__dirname,'build'));
</code></pre>
<blockquote>
<p>1.<code>path</code>常用的方法是：<code>resolve</code>---能够处理中间的混乱逻辑</p>
<p>2.<code>resolve</code>常用于取到绝对路径</p>
<p>3.<code>__dirname</code>是编译器预先声明的，是一个预处理命令，在运行时会替换为<code>当前目录</code></p>
</blockquote>
<h3 id="546-net模块">5.4.6 Net模块</h3>
<blockquote>
<p>是TCP/IP协议栈中<code>TCP协议</code>的Node实现</p>
<p><a href="http://nodejs.cn/api/net.html">参考文档</a></p>
</blockquote>
<h3 id="547-multiparty模块">5.4.7 Multiparty模块</h3>
<blockquote>
<p>可用于处理<code>post</code>请求的普通数据以及文件数据</p>
<p><a href="https://www.npmjs.com/package/multiparty">参考链接</a></p>
</blockquote>
<pre><code class="language-js">const http = require('http');
const multiparty = require('multiparty');

http.createServer((request,response)=&gt;{
    let form = new multiparty.Form({
        uploadDir: './upload'
    });

    form.parse(request);
	
    //处理普通的字段信息
    form.on('field',(key,value)=&gt;{
        console.log(&quot;Field:&quot;,key,value);
    });

    //处理文件信息
    form.on('file',(key,value)=&gt;{
        console.log(&quot;File:&quot;,key,value);
    });

    //结束后的处理
    form.on('close',()=&gt;{
        console.log(&quot;Parse Done&quot;);
    });
}).listen(8080);
</code></pre>
<h2 id="55-重要内容">5.5 重要内容</h2>
<h3 id="551-请求方式">5.5.1 请求方式</h3>
<h4 id="post方法">POST方法</h4>
<blockquote>
<p><code>post</code>特性</p>
<ul>
<li>是向服务器发送数据的</li>
</ul>
<ul>
<li>
<p>数据放在http的body中传输，容量大</p>
</li>
<li>
<p><strong>注意</strong>：由于数据量大，post常会将数据分成<strong>报文段</strong>的形式传递给服务器；而get数据则一次全部传递</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>1.普通<code>post</code>数据处理方法——使用<code>querystring</code>模块</p>
<p>通过<code>request</code>中的事件来进行处理</p>
</blockquote>
<pre><code class="language-js">const http = require('http');
const querystring = require('querystring');

let server = http.createServer((request,response)=&gt;{
    //区分请求是get还是post
    console.log(request.method);
    
    let arr = [];

    //对于数据到来事件的处理
    request.on(&quot;data&quot;,(buffer)=&gt;{
        //数据的片段都存到数组中
        arr.push(buffer);
    });
    
    //数据接收完毕事件到来的处理
    request.on(&quot;end&quot;,()=&gt;{
        //最后将数组的各元素拼接
        let result = Buffer.concat(arr);
        //这里接收到的是二进制数据，一般不将其转为String-特别是对于文件数据而言
        console.log(result);
        
        //同样可以使用querystring来进行解析
        let query = JSON.stringify(querystring.parse(result.toString()));
        console.log(query);
    });
});

server.listen(8080);
</code></pre>
<blockquote>
<p>2.<code>Post</code>的文件数据处理</p>
</blockquote>
<ul>
<li>
<p>想要传输文件时，需要将表单中的<code>enctype</code>属性修改为：<code>multipart/form-data</code></p>
<ul>
<li>其默认值为<code>enctype=&quot;application/x-www-form-urlencoded&quot;</code>，它只能够传输文字类的数据</li>
</ul>
</li>
<li>
<p>通过以上方式传递到服务器的<code>buffer数据</code>：重点在于分隔符(可以在<code>headers</code>中得到)</p>
<ul>
<li>其形式为<code>分隔符 \r\n字段信息\r\n\r\n内容\r\n</code>，其中<code>\r\n</code>表示换行</li>
</ul>
</li>
</ul>
<pre><code class="language-js">//headers
{
  host: 'localhost:8080',
  connection: 'keep-alive',
  'content-length': '397',
  'cache-control': 'max-age=0',
  origin: 'http://localhost:63342',
  'upgrade-insecure-requests': '1',
  'content-type': 'multipart/form-data; boundary=----WebKitFormBoundarykVTPOqbJHbSLReI8',
  'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36',
  'sec-fetch-user': '?1',
  accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',
  'sec-fetch-site': 'same-site',
  'sec-fetch-mode': 'navigate',
  referer: 'http://localhost:63342/Node/NodeTwo/file.html?_ijt=sag47n080029rup9al2lh73e4',
  'accept-encoding': 'gzip, deflate, br',
  'accept-language': 'zh-CN,zh;q=0.9',
  cookie: 'goSessionid=Jho1usKr1IqyRT8AmntZOA0FQAPzBcoWbTQYLHqRjhA%3D; _ga=GA1.1.959169682.1564577928; Webstorm-1e855c85=c4451dba-0755-49de-a2b2-d72f07123076'
}

//数据
------WebKitFormBoundaryNahOkzPkQAZ9BkmX
Content-Disposition: form-data; name=&quot;name&quot;

RichardTao
------WebKitFormBoundaryNahOkzPkQAZ9BkmX
Content-Disposition: form-data; name=&quot;psd&quot;

123456
------WebKitFormBoundaryNahOkzPkQAZ9BkmXs
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;
Content-Type: text/plain

richard
abc
8900
------WebKitFormBoundaryNahOkzPkQAZ9BkmX--
</code></pre>
<blockquote>
<p>在<code>Node.js</code>中最重要的就是知道如何灵活地去运用各个模块，而不是亲力亲为去自己实现模块</p>
</blockquote>
<ul>
<li>使用<code>multiparty</code>模块来实现<code>Post</code>的文件数据处理</li>
</ul>
<pre><code class="language-js">const http = require('http');
const multiparty = require('multiparty');

http.createServer((request,response)=&gt;{
    let form = new multiparty.Form({
        uploadDir: './upload'
    });

    form.parse(request);
	
    //处理普通的字段信息
    form.on('field',(key,value)=&gt;{
        console.log(&quot;Field:&quot;,key,value);
    });

    //处理文件信息
    form.on('file',(key,value)=&gt;{
        console.log(&quot;File:&quot;,key,value);
    });

    //结束后的处理
    form.on('close',()=&gt;{
        console.log(&quot;Parse Done&quot;);
    });
}).listen(8080);
</code></pre>
<h4 id="get方法">Get方法</h4>
<blockquote>
<p><code>get</code>特性</p>
<ul>
<li>是从服务器中获取数据</li>
<li>数据放在url中传输的，即放在<code>http的头部</code>中进行传输，容量小</li>
</ul>
<ul>
<li><strong>常使用的模块</strong>： <code>queryString</code>以及<code>url</code>模块来对数据进行解析</li>
</ul>
</blockquote>
<h4 id="综合案例">综合案例</h4>
<blockquote>
<p>综合处理-<code>server-total.js</code></p>
</blockquote>
<pre><code class="language-js">const http = require('http');
const fs = require('fs');
const url = require('url');
const querystring = require('querystring');

let users = {};

http.createServer((request, response) =&gt; {
    let path = '', get = {}, post = {};

    if (request.method === 'GET') {
        let { pathname, query } = url.parse(request.url, true);
        path = pathname;
        get = query;
        complete();
    } else if (request.method === 'POST') {
        path = request.url;

        let arr = [];
        request.on('data', buffer =&gt; {
            arr.push(buffer);
        });

        request.on('end', () =&gt; {
            let result = Buffer.concat(arr);
            post = JSON.stringify(querystring.parse(result.toString()));
            complete();
        });

    }

    /**
     * 该函数用于对前台数据的判断
     */
    function complete() {
        // console.log(path, get, post);
        if (path === '/reg') {
            //对注册的请求
            // let username = get.username;
            // let password = get.password;
            // console.log(username,password);
            let { username, password } = get;

            if (users[username]) {
                response.write(JSON.stringify({
                    error: 1,
                    msg: '该用户已经注册'
                }));
                response.end();
            } else {
                users[username] = password;
                response.write(JSON.stringify({
                    error: 0,
                    msg: ''
                }));
                response.end();
            }

        } else if (path === '/login') {
            //对登录的请求

            let { username, password } = get;
            // let username = get.username;
            // let password = get.password;
            // console.log(get);
            // console.log(username,password);

            //排除错误
            // if (users[username]) {
            //     console.log(users[username].password,password);
            // }

            if (!users[username]) {
                response.write(JSON.stringify({
                    error: 1,
                    msg: '用户名不存在'
                }));
                response.end();
            } else if (users[username] !== password) {
                response.write(JSON.stringify({
                    error: 1,
                    msg: '用户名与密码不匹配'
                }));
                response.end();
            } else {
                response.write(JSON.stringify({
                    error: 0,
                    msg: ''
                }));
                response.end();
            }

        } else {
            //均不是，则必定是对静态资源的请求
            fs.readFile(`www${path}`, (err, buffer) =&gt; {
                if (err) {
                    response.writeHead(404);
                    response.write('Not Found');
                    response.end();
                } else {
                    response.write(buffer);
                    response.end();
                }
            });
        }
    }

}).listen(8080);
</code></pre>
<h3 id="552-packagejson文件">5.5.2 package.json文件</h3>
<h4 id="简要介绍">简要介绍</h4>
<blockquote>
<p>通过<code>npm init -y</code>命令生成一个默认的文件</p>
<p>该文件是发布该工程所必须的</p>
</blockquote>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Node&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;01test.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/2020-02-08_15-36-55.png" alt="" loading="lazy"></figure>
<h4 id="重要的属性">重要的属性</h4>
<ul>
<li>
<p><code>scripts</code>属性：用于书写工程部署时一些脚本</p>
</li>
<li>
<p><code>dependencies</code>属性：它所表示的是当前工程运行所依赖的一些包/库</p>
<ul>
<li>
<p>在工程移动/汇总时，不必将目录下的<code>node_modules</code>一并移动，只需要<code>package.json</code>这一个文件即可。而其<strong>依赖的包</strong>通过命令<code>cnpm i</code>即可将所有的包全部下载下来。</p>
<blockquote>
<p><code>&quot;^1.1.1&quot;</code>：版本号中有一个<code>^</code>表示兼容当前工程的最高版本；除此之外，包的版本属性还可以是：<code>latest</code>-不建议使用，<code>1.1.*</code>等</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="553-多进程">5.5.3 多进程</h3>
<blockquote>
<p>Node是一个多进程的语言</p>
<p>使用<code>cluster.fork()</code>将主进程复制出来一个子进程</p>
<p><code>前台JS</code>使用<code>new Worker()</code>来创建</p>
<p>但是实际上JS中使用的更多的是一种<code>基于事件的方式</code></p>
</blockquote>
<p>作用：</p>
<ul>
<li>保护主进程的安全，从而开辟子进程，这样子进程终止也不会影响到主进程继续运行</li>
<li>主进程中任务太多，为了充分发挥多核CPU的功效，将任务分成多个进程来完成</li>
</ul>
<h3 id="554-sessioncookie">5.5.4 <code>Session</code>&amp;<code>Cookie</code></h3>
<h4 id="cookie"><code>cookie</code></h4>
<ul>
<li>
<p>cookie 是存储于访问者的计算机中的变量。可以让我们<strong>用同一个浏览器访问同一个域名的时候共享数据</strong>。</p>
</li>
<li>
<p>HTTP是<strong>无状态协议</strong>。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。</p>
</li>
<li>
<blockquote>
<p>Cookie是一个简单到爆的想法：当访问一个页面的时候，服务器在下行HTTP报文中，命令浏览器存储一个字符串; 浏览器再访问同一个域的时候，将把这个字符串携带到上行HTTP请求中。第一次访问一个服务器，不可能携带cookie。 必须是服务器得到这次请求，在下行响应报头中，携带cookie信息，此后每一次浏览器往这个服务器发出的请求，都会携带这个cookie。</p>
</blockquote>
</li>
</ul>
<h4 id="session"><code>session</code></h4>
<blockquote>
<p>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。 客户的信息都保存在session中</p>
</blockquote>
<h2 id="56-数据通信">5.6 数据通信</h2>
<h3 id="561-ajax和跨域">5.6.1 Ajax和跨域</h3>
<blockquote>
<p>即<code>XMLHttpRequest</code></p>
<p>原生的<code>Ajax</code>不能跨域，其学名为<code>SOP</code>(同源限制)：即浏览器要求请求的域名和服务器回应的域名需要一致，否则浏览器就要将服务器返回的数据丢弃</p>
<p>故：不能跨域的原因在于<code>浏览器</code>，与服务器无关</p>
<p>这时前台无法解决，需要服务器端对返回的数据进行声明，即服务器允许浏览器请求它的资源，让浏览器放这个数据通过</p>
</blockquote>
<pre><code class="language-js">//服务器端
const http = require('http');

http.createServer((request,response)=&gt;{
    //需要跨域时，不过实际中需要判断这个是自己人
    response.setHeader('Access-Control-Allow-Origin','*');

    response.write('{&quot;a&quot;:&quot;abc&quot;,&quot;b&quot;:29}');
    response.end();
}).listen(8080);
</code></pre>
<pre><code class="language-html">&lt;!-- 客户端 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        window.onload = function () {
          let req = document.getElementById('reqBtn');
          req.onclick = function () {
            let ajax = new XMLHttpRequest();

            //首先打开连接，最后一个属性必须是true(因为浏览器已经不支持同步的方法)
            ajax.open('GET','http://localhost:8080/',true);
            //先body中发送数据，但是由于我们是get方式，故这里不传入数据
            ajax.send();

            ajax.onreadystatechange = ()=&gt;{
                /**
                 * readyState(0-4)，状态逐渐递进
                 *  0-初始化，1-已连接，2-已发送，3-已接收head，4-已接收body
                 */
                if (ajax.readyState===4){
                    if (ajax.status &gt;= 200 &amp;&amp; ajax.status&lt;=300 || ajax.status===304){
                        alert('Success');
                        console.log(JSON.parse(ajax.responseText));
                    }else {
                        alert('Fail');
                    }
                }
            }
          };
        };
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;button&quot; value=&quot;请求&quot; id=&quot;reqBtn&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="562-fetch">5.6.2 Fetch</h3>
<blockquote>
<p>是原生的对象，比<code>xhr</code>要简单得多，不用引入其他的文件/框架</p>
<p>使用步骤，注意要使用异步的方法(即<code>async,await</code>)：</p>
<p>1.请求</p>
<p>2.解析：处理其他类型的数据只需调用对应的方法即可，不过对于二进制的数据(比如图片、视频文件)，由于它不能够则需要借助于浏览器来完成解析</p>
</blockquote>
<pre><code class="language-js">$(function () {
            $(&quot;#testBtn1&quot;).on('click', async function () {
                let res1 = await fetch('data/1.txt');
                // 处理文本数据
                let textRes = await res.text();

                let res2 = await fetch('data/1.json');
                // 处理JSON数据
                let jsonRes = await res.json();

                let res3 = await fetch('data/1.png');
                let blobRes = await res.blob();
                //该方法可以让浏览器将传入的二进制数据写入一个临时文件中
                let url = URL.createObjectURL(blobRes);

                // console.log(textRes);
            });
});
</code></pre>
<h3 id="563-jsonp">5.6.3 jsonp</h3>
<blockquote>
<p>在<code>ajax</code>不能跨域的年代，<code>jsonp</code>使用很多，它不需要通过服务器的请求、可以直接拿到服务器的数据从而完成跨域</p>
<p><a href="https://blog.csdn.net/badmoonc/article/details/82289252">jsonp原理</a></p>
</blockquote>
<pre><code class="language-js">&lt;script&gt;
        function show({s}) {
            console.log(s);
        }
        window.onload = function () {
            let search = document.getElementById('search');
            search.oninput = function () {
                let url = `https://www.baidu.com/sugrec?ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;wd=${this.value}&amp;cb=show`;
                let script = document.createElement('script');
                script.src = url;
                document.head.appendChild(script);
            };
        };

		//jquery方法完成jsonp请求
		$(function () {
            $(&quot;#search&quot;).on('input',function () {
                $.ajax({
                    url: 'http://suggestion.baidu.com/su',
                    data: {wd:$(this).val()},
                    //类型要声明为jsonp
                    dataType: 'jsonp',
                    //值为回调方法的名字
                    jsonp: 'cb'
                }).then(({s})=&gt;{
                    console.log(s);
                },res=&gt;{
                    alert('fail');
                });
            });
        });
&lt;/script&gt;
</code></pre>
<h3 id="564-ajax20与formdata">5.6.4 ajax2.0与formdata</h3>
<blockquote>
<p>与之前相比，增加了一个<code>表单数据</code>的东西，即此时可以将表单作为一个整体的数据单位来进行传递，其中包含了表单的全部数据</p>
</blockquote>
<h4 id="formdata"><code>formdata</code></h4>
<pre><code class="language-js">//创建一个formdata对象
//可以传递一个表单元素-作为表单数据
let formdata = new FormData(oform);
//也可以创建一个空的表单数据，然后向其中追加数据
formdata.append('age',document.getElementById('username').value);
</code></pre>
<h4 id="后台nodejs">后台：node.js</h4>
<pre><code class="language-js">const http = require('http');
const multiparty = require('multiparty');

http.createServer((request,response)=&gt;{
    let form = new multiparty.Form({
        uploadDir: '../data'
    });

    form.parse(request);

    //处理普通的字段信息
    form.on('field', (key, value) =&gt; {
        console.log(&quot;Field:&quot;, key, value);
    });

    //处理文件信息
    form.on('file', (key, value) =&gt; {
        console.log(&quot;File:&quot;, key, value);
    });

    //结束后的处理
    form.on('close', () =&gt; {
        console.log(&quot;Parse Done&quot;);
    });
}).listen(63342);
</code></pre>
<h4 id="原生xhr方法">原生xhr方法</h4>
<blockquote>
<p>注意要点：</p>
<p>1.表单中使用<code>post</code>方法传递数据时要使用<code>ajax.send()</code>方法向<code>body</code>中传入数据</p>
<p>2.在将数据传入后台服务器之前要组织表单自动提交的默认行为：<code>return false</code></p>
</blockquote>
<pre><code class="language-js">window.onload = function () {
        let oform = document.getElementById('form1');

        oform.onsubmit = function () {
            let formdata = new FormData(oform);
            let ajax = new XMLHttpRequest();

            // ajax.open(oform.method, oform.action, true);
            ajax.open(oform.method, oform.action, true);
            //post方法需要传入参数
            ajax.send(formdata);

            ajax.onreadystatechange = () =&gt; {
                if (ajax.readyState === 4) {
                    if (ajax.status === 200) {
                        alert('Success');
                        // console.log(JSON.parse(ajax.responseText));
                    } else {
                        alert('Fail');
                    }
                }
            };

            //组织表单的默认行为
            return false;
        };
    };
</code></pre>
<h4 id="jquery的ajax方法">jquery的ajax方法</h4>
<blockquote>
<p>注意要点：</p>
<p>1.<code>processData: false</code>：阻止<code>jquery</code>自动将表单数据转为<code>json</code>格式传输</p>
<p>2.<code>contentType: false</code>：不修改其格式</p>
<p>3.<code>data</code>：可以直接填入表单数据<code>formdata</code>，并告诉<code>jquery</code>库不需要去修改这个数据，该数据可以直接递交到后台处理</p>
</blockquote>
<pre><code class="language-js">$(function () {
            $('#form1').on('submit', function () {
                let formData = new FormData(this);
                console.log(this.action, this.method,formData);

                $.ajax({
                    url: this.action,
                    type: this.method,
                    data: formData,
                    //告诉jquery不要将数据转为json，就使用原始的数据
                    processData: false,
                    //不要随便修改content-type
                    contentType: false
                }).then(function () {
                    alert('Success');
                }, function () {
                    alert('Fail');
                });

                //组织表单的默认行为
                return false;
            });
        });
</code></pre>
<h3 id="565-websocket">5.6.5 websocket</h3>
<blockquote>
<p>特点：</p>
<p>1.性能高：比<code>ajax</code>高2-10倍左右</p>
<p><strong>2.双向通信</strong>：<code>ajax</code>只有浏览器主动向服务器发出数据请求，而不能反向(<code>ajax</code>做到这一点需要服务器以定时器的方式轮询浏览器是否发送了数据请求，这样容易造成浪费资源)</p>
</blockquote>
<h4 id="socketio"><code>socket.io</code></h4>
<blockquote>
<p>特点：本身并不独立于协议，它仍然需要普通的<code>http/s</code>服务，它通过监视<code>http/s</code>的服务，一旦有请求<code>http/s</code>它就会将这个服务拿过来与对应的客户端通信、完成交互</p>
<p>可以将所有的<code>http</code>换成<code>websocket</code>，比前者更加省资源</p>
<p>优势：</p>
<p>1.简单、方便：相较于原生的<code>websocket</code>而言</p>
<p>2.兼容性高，可以兼容到<code>ie5</code></p>
<p>3.自动数据解析</p>
</blockquote>
<pre><code class="language-js">//后端
const socket = require('socket.io');
const chalk = require('chalk');
const http = require('http');

//1. 建立普通http
let server = http.createServer((req,res)=&gt;{});
server.listen(8080);

//2. 建立ws-websocket
let ws = socket.listen(server);
//客户端连接事件，在连接建立完成之后返回一个连接对象socket1
ws.on('connection',socket1 =&gt; {
    //发送数据，第一个参数为事件-需要与前端一致
    setInterval(function () {
        socket1.emit('date', new Date());
    }, 500);
    
    //接收数据，第一个参数为事件-需要与前端一致
    socket1.on('fontData',function () {
    });
});
</code></pre>
<pre><code class="language-js">//前端
&lt;script src=&quot;http://localhost:8080/socket.io/socket.io.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;script&gt;
        //连接服务端，注意协议中不再是http协议，而是ws
        let sock = io.connect('ws://localhost:8080/');
        //发送数据
        sock.emit('frontData',122,133);
        //接收数据
        sock.on('date',time=&gt;{
            console.log(time);
        });
&lt;/script&gt;
</code></pre>
<h4 id="原生websocket">原生<code>websocket</code></h4>
<blockquote>
<p>很少用，很麻烦</p>
</blockquote>
<h2 id="57-数据库">5.7 数据库</h2>
<h3 id="571-分类">5.7.1 分类</h3>
<blockquote>
<p>文件型：最简单适合单机存储数据，常用的有<code>access</code>,<code>sqlite</code>-客户端存储信息</p>
<p>关系型：<code>mysql</code>、<code>oracle</code>-后端主要数据</p>
<p>分布式：<code>mongoDB</code></p>
<p>NoSQL：不支持复杂查询，但性能高、自带分布，<code>memcache</code>、<code>redis</code>-缓存</p>
</blockquote>
<h3 id="572-安全性">5.7.2 安全性</h3>
<blockquote>
<p>数据库最主要的部分，主要是防止<code>Sql注入</code></p>
</blockquote>
<h3 id="573-操作">5.7.3 操作</h3>
<blockquote>
<p>分为两个部分：</p>
<p>1.管理型的操作</p>
<p>2.增删改查</p>
</blockquote>
<h4 id="数据库字段">数据库字段</h4>
<pre><code class="language-sql">数字类型：
int,tinyint

文本类型：
varchar-存储短文本，可以指定大小
text-存储长文本，最多可存储2G大小
</code></pre>
<h3 id="574-node操作数据库">5.7.4 Node操作数据库</h3>
<blockquote>
<p>在实际中，数据库所在的服务器与处理<code>web</code>请求的服务器不是同一个，需要通过网络进行数据通信，因此在<code>node</code>中操作数据库同样是<code>异步操作</code>为主</p>
</blockquote>
<h4 id="数据库连接">数据库连接</h4>
<pre><code class="language-js">//连接数据库
let db = mysql.createConnection({
    host: 'localhost',
    port: '3306',
    user: 'root',
    password: '123456',
    database: 'learn'
});
</code></pre>
<pre><code class="language-js">//数据库连接池
//创建数据库连接池
let db = mysql.createPool({
    //最大连接数
    // connectionLimit: 10,
    host: 'localhost',
    port: '3306',
    user: 'root',
    password: '123456',
    database: 'learn'
});
</code></pre>
<h4 id="数据库操作">数据库操作</h4>
<blockquote>
<p>1.查询数据库：返回的结果可以直接转为<code>json</code>格式，这样就可以直接交给前台使用</p>
<p>2.插入数据库：其返回的数据包括有如上的字段信息，特别是<code>insertId</code>信息可以利用</p>
</blockquote>
<pre><code class="language-js">//查询数据库
db.query('select * from user',(err,data)=&gt;{
    if (err) {
        console.log(chalk.yellow('Error'),err);
    } else {
        //data可以直接使用json方法的stringify将其转为JSON
        console.log(data);
    }
});

//插入数据库
let username = 'taocong';
let password = '128jn';
db.query(`insert into user(username,password) values('${username}','${password}')`,(err,data)=&gt;{
    if (err) {
        console.log(chalk.yellow('Error'),err);
    } else {
        //data可以直接使用json方法的stringify将其转为JSON
        console.log(data);
    }
});
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/2020-02-10_21-30-29.png" alt="" loading="lazy"></figure>
<h4 id="异步操作">异步操作</h4>
<pre><code class="language-js">//与http配合
http.createServer((req, res) =&gt; {
    let {
        pathname,
        query
    } = url.parse(req.url, true);

    if (pathname === '/reg') {
        //1，参数是否正确
        let {
            username,
            password
        } = query;

        if (!username || !password) {
            res.write('用户名或密码不能为空');
        } else if (username.length &gt; 32) {
            res.write('用户名最大为32个字符');
            res.end();
        } else if (password.length &gt; 32) {
            res.write('密码最大为32个字符');
            res.end();
        } else {
            //2,用户名是否被用过,注意参数都要以引号括起来，否则会出错
            db.query(`select ID from user where username='${username}'`, (err, data) =&gt; {
                if (err) {
                    res.write('数据库出错，请稍后重试');
                    res.end();
                } else if (data.length &gt; 0) {
                    //说明此时有同名的数据存在
                    res.write('用户名已经被占用');
                    res.end();
                } else {
                    //3,可以向数据库中插入数据
                    db.query(`insert into user(username,password) values('${username}','${password}')`, (err, data) =&gt; {
                        if (err) {
                            res.write('数据库出错');
                            res.end();
                        } else {
                            res.write('操作成功');
                            res.end();
                        }
                    })
                }
            })
        }
    } else if (pathname === '/login') {

    } else {
        fs.readFile(`www${pathname}`, (err, buffer) =&gt; {
            if (err) {
                res.writeHeader(404);
                res.write('Not Found');
            } else {
                res.write(buffer);
            }
            res.end();
        })
    }
}).listen(8080);
</code></pre>
<blockquote>
<p>缺点很明显，由于回调的多层嵌套导致代码的可阅读性很差，因此可以使用模块：</p>
<p><code>co-mysql</code>来解决这种问题，使得这些异步操作用同步的状态来编码-<code>async &amp; await</code></p>
<p>改进后的代码如下：</p>
</blockquote>
<pre><code class="language-js">if (pathname === '/reg') {
        //1，参数是否正确
        let {
            username,
            password
        } = query;

        if (!username || !password) {
            res.write('用户名或密码不能为空');
        } else if (username.length &gt; 32) {
            res.write('用户名最大为32个字符');
            res.end();
        } else if (password.length &gt; 32) {
            res.write('密码最大为32个字符');
            res.end();
        } else {
            //对于出现的错误，使用try...catch来处理
            try {
                let dataRes = await db.query(`select ID from user where username='${username}'`);
                if (dataRes.length &gt; 0) {
                    //说明此时有同名的数据存在
                    res.write('用户名已经被占用');
                } else {
                    let insertRes = db.query(`insert into user(username,password) values('${username}','${password}')`);
                    res.write('注册成功');
                }
            } catch (error) {
                res.write('数据库出错');
            }
            res.end();
        }
    }
</code></pre>
<ul>
<li><code>await</code>后面可以有以下几种：
<ul>
<li><code>await Promise</code></li>
<li><code>await fn(){return Promise}</code></li>
<li><code>await async ()=&gt;{}</code></li>
</ul>
</li>
</ul>
<h2 id="58-原生node整合">5.8 原生<code>Node</code>整合</h2>
<h3 id="581-流操作">5.8.1 流操作</h3>
<blockquote>
<p>过去的文件读取做法是通过<code>fs.readFile</code>完成，但是这种方法的弊端十分明显：即在读取文件的时候它会一次性将文件全部读取到服务器的内存之后才会发送出去。</p>
<p>故：存在有<code>内存占用高</code>以及<code>资源使用和磁盘、网络工作不均衡</code>的问题</p>
<p>这时，可以使用流操作——<code>读一块、发送一块</code></p>
</blockquote>
<h4 id="基本用法">基本用法</h4>
<pre><code class="language-js">const fs = require('fs');
const chalk = require('chalk');
const zlib = require('zlib');

//readStream
let readS = fs.createReadStream('./data/source.txt');

let gz = zlib.createGzip();
//writeStream
let writeS = fs.createWriteStream('./data/dest.txt.gz');

//管道函数，注意顺序不能反了
readS.pipe(writeS);

//读写流：使用场景有压缩、加密等等
readS.pipe(gz).pipe(writeS);

//错误处理事件
readS.on('error',err=&gt;{
    console.log(err);
});

//只有当写入流完成之后，才是结束
writeS.on('finish',()=&gt;{
    console.log(chalk.yellow('完成'));
});

</code></pre>
<h4 id="cs场景流操作">C/S场景流操作</h4>
<blockquote>
<p>实际上，在<code>http</code>中内置的<code>req &amp; res</code>都是内置的流对象</p>
<p>注意事项：</p>
<p>1.在请求资源时，需要先判断文件是否存在，再去决定是否读取</p>
<p>2.在压缩后将文件发送给浏览器时，需要设置<code>header</code>中的<code>content-encoding</code>属性，告诉浏览器这并不是普通的格式，要以gzip的格式处理</p>
<p>3.<code>content-encoding</code>有以下的值，表示不同含义<br>
<code>gzip</code>为压缩的文件<br>
<code>deflate</code>为普通二进制的数据，即buffer<br>
<code>空</code>表示字符串数据</p>
</blockquote>
<pre><code class="language-js">const http = require('http');
const fs = require('fs');
const url = require('url');
const zlib = require('zlib');
const chalk = require('chalk');

http.createServer((req, res) =&gt; {
    let {
        pathname,
        query
    } = url.parse(req.url, true);

    let filePath = `data${pathname}`;

    //需要先判断文件是否存在，再去决定是否读取
    fs.stat(filePath, (err, stats) =&gt; {
        if (err) {
            res.writeHeader(404);
            res.write('File Not Found');
            res.end();
        } else {
            let readS = fs.createReadStream(filePath);
            let gz = zlib.createGzip();
            //需要设置header，告诉浏览器这并不是普通的格式，要以gzip的格式处理
            /**
             * content-encoding
             *  - gzip为压缩的文件
             *  - deflate为普通二进制的数据，即buffer
             *  - 空表示字符串数据
             */
            res.setHeader('content-encoding', 'gzip');
            //仍然需要捕获错误，防止文件中途删除了
            readS.on('error', err =&gt; {});
            readS.pipe(gz).pipe(res);
        }
    });

}).listen(8080);
</code></pre>
<h3 id="582-启动器">5.8.2 启动器</h3>
<blockquote>
<p>常用的且简单的启动器：<code>forever</code>/<code>pm2</code>，在<code>cmd</code>窗口关闭时仍然会运行，并且在机器重启之后会将服务器文件启动起来。</p>
<p>下载：<code>cnpm i forever -g</code></p>
<p>启动命令：<code>forever start xxx.js</code></p>
<p>重启命令：<code>forever restart xxx.js</code></p>
<p>关闭命令： <code>forever stop xxx.js</code></p>
<p>关闭所有： <code>forever stopall</code></p>
<p>查看启动的服务器：<code>forever list</code></p>
<p>选项：<code>-l: log</code>，<code>-o: 普通数据</code>，<code>-e: 错误信息</code>，<code>-a: 不清除日志，继续追加</code></p>
</blockquote>
<h3 id="583-路由表">5.8.3 路由表</h3>
<blockquote>
<p>若是在代码中重复地使用<code>if/else</code>来判断请求的话，代码会变得十分冗余难以阅读，因此可以使用<code>router.js</code>来统一管理这些请求的添加</p>
</blockquote>
<pre><code class="language-js">//路由表

let router = {};

/**
 * 
 * @param {*} method get &amp; method
 * @param {*} url 用户访问的接口, '/login'
 * @param {*} fn 回调函数
 */
function addRouter(method, url, fn) {
    method = method.toLowerCase();
    url = url.toLowerCase();

    //如果有则返回对应方法，没有则新建
    router[method] = router[method] || {};
    router[method][url] = fn;
}

function findRouter(method, url) {
    method = method.toLowerCase();
    url = url.toLowerCase();

    //如果为空则表示找不到
    if (!router[method] || !router[method][url]) {
        return null;
    } else {
        //否则返回对应的方法
        return router[method][url];
    }
}

module.exports = {
    addRouter,
    findRouter
}
</code></pre>
<h3 id="584-参数配置文件-数据库http">5.8.4 参数配置文件-数据库&amp;HTTP</h3>
<blockquote>
<p>将数据库以及<code>http</code>中所涉及的参数统一放在一个配置文件中，这样在后续的开发中只需要修改配置文件中的内容即可快速完成同步</p>
<p>并将配置文件与当前服务器的系统相配套，通过<code>process</code>中的参数不同来自动匹配使用不同的参数配置文件</p>
</blockquote>
<pre><code class="language-js">//配置文件
const path = require('path');

module.exports = {
    //database
    DB_HOST: 'localhost',
    DB_PORT: '3306',
    DB_USER: 'root',
    DB_PASSWORD: '123456',
    DB_NAME: 'learn',

    //http
    HTTP_PORT: '8080',
    //静态文件的目录
    HTTP_ROOT: path.resolve(__dirname,'../static'),
    HTTP_UPLOAD: path.resolve(__dirname,'../upload')
};
</code></pre>
<pre><code class="language-js">//判断
const process = require('process');

let mode = (process.env.OS == 'Windows_NT' ? 'dev' : 'produ')

// console.log(process.env);
// console.log(mode);

module.exports = {
    mode,
    ...(mode == 'dev' ? require('./config.dev') : require('./config.produ'))
};
</code></pre>
<h3 id="585-http处理封装">5.8.5 <code>http</code>处理封装</h3>
<pre><code class="language-js">const http = require('http');
const url = require('url');
const zlib = require('zlib');
const querystring = require('querystring');
const fs = require('fs');
const {
    HTTP_PORT,
    HTTP_ROOT,
    HTTP_UPLOAD
} = require('./config');
const {
    Form
} = require('multiparty');
const chalk = require('chalk');
const router = require('./router');

http.createServer((req, res) =&gt; {
    /**
     * 向res中添加写json数据的方法
     */
    res.writeJSON = function(json){
        res.setHeader('content-type','application/json');
        res.write(JSON.stringify(json));
    };

    /**
     * description: 找路由的方法
     * @param {*} method get/post
     * @param {*} url /login
     * @param {*} get query data
     * @param {*} post post data
     * @param {*} file file data
     */
    async function handle(method, url, get, post, file) {
        let fn = router.findRouter(method, url);
        if (!fn) {
            //认为请求的是文件
            let filepath = HTTP_ROOT + pathname;
            fs.stat(filepath, (err, stat) =&gt; {
                if (err) {
                    res.writeHeader(404);
                    res.write('File Not Found');
                    res.end();
                } else {
                    let rs = fs.createReadStream(filepath);
                    let gz = zlib.createGzip();

                    res.on('error', () =&gt; {});
                    res.setHeader('content-encoding', 'gzip');
                    res.setHeader('content-type','text/plain;charset=utf-8');

                    rs.pipe(gz).pipe(res);
                }
            });
        } else {
            //请求的是接口
            try {
                //由于在addRouter中我们用的是async方法，故这里也要是异步的
                await fn(res, get, post, file);
            } catch (error) {
                res.writeHeader(500);
                res.write('Internal Server Error');
                res.end();
            }
        }
    }


    let {
        pathname,
        query
    } = url.parse(req.url, true);

    if (req.method == 'POST') {
        if (req.headers['content-type'].startsWith('application/x-www-form-urlencoded')) {
            //普通post
            let arr = [];
            req.on('data', buffer =&gt; {
                arr.push(buffer);
            });
            req.on('end', () =&gt; {
                let post = querystring.parse(Buffer.concat(arr).toString());

                //找路由
                handle(req.method, pathname, query, post, {});
            })
        } else {
            //文件post
            let form = new Form({
                uploadDir: HTTP_UPLOAD
            });

            form.parse(req);

            //存放post数据和文件数据
            let post = {},
                files = {};

            form.on('field', (name, value) =&gt; {
                post[name] = value;
            });

            form.on('file', (name, value) =&gt; {
                files[name] = value;
            });

            form.on('error', err =&gt; {
                console.log(err);
            });

            form.on('close', () =&gt; {
                //找路由
                handle(req.method, pathname, query, post, files);
            });
        }

    } else {
        //req.method == 'GET'
        //找路由
        handle(req.method, pathname, query, {}, {});
    }

}).listen(HTTP_PORT);

console.log(chalk.red(`Server is starting at port ${HTTP_PORT}`));
</code></pre>
<h3 id="586-具体调用">5.8.6 具体调用</h3>
<blockquote>
<p>注意使用以下方式，来避免<code>sql注入</code></p>
<p><code>db.query(insert into items(title,price,count) values(?,?,?), [title, price, count])</code></p>
</blockquote>
<pre><code class="language-js">//引入config时，默认回去找config目录下的index.js
const config = require('./config');
const db = require('./database');
const myhttp = require('./http');
const {
    addRouter
} = require('./router');

/**
 * 开发、生产过程中会使用到很多套配置，因此需要定义配置文件
 * 以方便修改和使用
 */
// console.log(config);


addRouter('get', '/list', async (res, get, post, files) =&gt; {
    try {
        let data = await db.query('select * from items');
        // console.log(data);
        
        res.writeJSON({
            error: 0,
            data
        });
    } catch (error) {
        res.writeJSON({
            error: 1,
            msg: 'Database Error'
        });
    }

    res.end();
});

addRouter('get', '/add', async (res, get, post, files) =&gt; {
    let {
        title,
        price,
        count
    } = get;

    // console.log(title,price,count);
    

    if (!title || !price || !count) {
        res.writeJSON({
            error: 1,
            msg: 'Params invalid'
        });
    } else {
        count = Number(count);
        if (isNaN(count)) {
            res.writeJSON({
                error: 1,
                msg: 'Params invalid, NaN'
            });
            res.end();
        } else {
            try {
                await db.query(`insert into items(title,price,count) values(?,?,?)`, [title, price, count]);
                res.writeJSON({
                    error: 0,
                    msg: 'Success'
                })
            } catch (error) {
                res.writeJSON({
                    error: 1,
                    msg: 'DataBase Error'
                });

            }
            res.end();
        }

    }
});

addRouter('get', '/addNum', async (res, get, post, files) =&gt; {
    res.write(parseInt(get['a']) + parseInt(get['b']));
    res.end();
});
</code></pre>
<h2 id="59-框架-express">5.9 框架-Express</h2>
<h3 id="591-基本使用">5.9.1 基本使用</h3>
<blockquote>
<p><a href="https://www.runoob.com/w3cnote/express-4-x-api.html">1.中文参考文档</a></p>
<p><a href="http://expressjs.jser.us/3x_zh-cn/api.html">2.API参考</a></p>
<p><a href="http://www.expressjs.com.cn/4x/api.html">3.英文参考</a></p>
</blockquote>
<h4 id="创建对象">创建对象</h4>
<pre><code class="language-js">const express = require('express');

/**
 * 创建一个对象，仍然需要监听端口
 */
let server = express();
server.listen(8080);
</code></pre>
<h4 id="自带路由">自带路由</h4>
<blockquote>
<p><code>express</code>自带路由：<code>server.method</code>，这个方法可以是<code>get/post/use-不确定</code></p>
<p>注意：<code>use</code>中必须要使用<code>next()</code>,否则服务器将一直停在该方法中不会继续向下执行</p>
</blockquote>
<pre><code class="language-js">server.get('/a',(req,res,next)=&gt;{
    //可以发送任何类型的数据，框架自己解决格式问题
    res.send({
        error: 1,
        msg: 'too many'
    });
});

server.get('/b',(req,res,next)=&gt;{
    res.send('bbb');
});
</code></pre>
<h4 id="next方法"><code>next</code>方法</h4>
<blockquote>
<p>**作用：**决定是否继续执行下一个同名方法</p>
<p>在调用了<code>next()</code>之后就会运行下一个同名方法</p>
<p>而对于<code>method = use</code>而言，则表示继续调用<code>express</code>的剩下方法</p>
</blockquote>
<pre><code class="language-js">const querystring = require('querystring');

module.exports = (req, res, next) =&gt; {
    let arr = [];

    req.on('data', buffer =&gt; {
        arr.push(buffer);
    });

    req.on('end', () =&gt; {
        let post = querystring.parse(Buffer.concat(arr).toString());
        req.body = post;
        next();
    });
};
</code></pre>
<h3 id="592-中间件">5.9.2 中间件</h3>
<h4 id="static"><code>static</code></h4>
<blockquote>
<p>它是<code>express</code>中唯一自带的中间件</p>
<p>作用：设定静态文件/资源的目录，相当于我们之前所作的请求文件的<code>fs</code>的作用，它会自动将该文件返回给浏览器</p>
</blockquote>
<pre><code class="language-js">/**
 * static中间件-express自带的
 * 
 * express始终是自上而下运行的，而use方法又会拦截到所有的
 * 客户端请求，故通常要把它放在下面来执行
 */
server.use(express.static('./static/'));
</code></pre>
<h4 id="body-parser"><code>body-parser</code></h4>
<blockquote>
<p>对于<code>express</code>而言，处理不同数据的方式有以下几种：</p>
<p>1.<code>get</code>数据：可以直接使用<code>req.query</code>获得</p>
<p>2.<code>post</code>数据：需要通过中间件<code>body-parser</code>来获得</p>
<p>​	<strong>注意</strong>：使用<code>server.use(body.urlencoded())</code>处理用户上传的<code>post</code>数据，将处理后的数据放到<code>body</code>属性中，以便于后续方法继续使用处理</p>
<p>3.上传文件的数据处理：通过中间件<code>multer</code>来处理-但是它处理不了post数据</p>
</blockquote>
<pre><code class="language-js">const express = require('express');
const body = require('body-parser');
const multer = require('multer');

/**
 * 数据：
 * get：可以直接使用req.query获得
 * post：需要通过中间件来获得:body-parser
 * 上传文件的数据处理：通过中间件multer来处理-但是它处理不了post数据
 */

let server = express();
server.listen(8080);

//body-parser使用：要放在请求处理的前面执行
server.use(body.urlencoded());

server.post('/reg',(req,res)=&gt;{
    console.log(req.body);
    
    //send()中自带有end()
    res.send('Success');
});

</code></pre>
<h4 id="multer"><code>multer</code></h4>
<blockquote>
<p>处理上传文件的数据，但不能处理<code>post</code>数据</p>
<p>并且对于上传的文件会以随机字符的格式存储(<strong>不存储后缀名</strong>)</p>
</blockquote>
<pre><code class="language-js">const express = require('express');
const body = require('body-parser');
const multer = require('multer');

let server = express();
server.listen(8080);

//multer使用:any()是指处理任何类型、任何大小的文件
let obj = multer({dest: './upload'});
server.use(obj.any());

server.post('/reg',(req,res)=&gt;{
    console.log(req.files);

    //send()中自带有end()
    res.send('Success');
});

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/2020-02-13_16-58-00.png" alt="" loading="lazy"></figure>
<h4 id="cookie-parser"><code>cookie-parser</code></h4>
<blockquote>
<p>取出<code>cookie</code>中的数据以及向其中存储数据</p>
<p>可以使用签名的方式来进行存储-在初始化中间件是：<code>app.use(cookieParser)</code>，传入的第一个参数为singed secret作为签名的密钥</p>
<p>[进阶玩法Reference](E:\笔记\Node.js\参考资料\Express 使用进阶：cookie-parser 中间件实现深入剖析.md)</p>
</blockquote>
<pre><code class="language-js">const express = require('express');
const cookieParser = require('cookie-parser');

let app = express();
app.listen(8080);

//初始化中间件，传入的第一个参数为singed secret作为签名的密钥
app.use(cookieParser(
    '123456bcijji'
));

app.get('/getCookie', (req, res) =&gt; {
    //获取的是未签名的数据
    console.log('Cookie: ', req.cookies);
    //获取签名后的数据
    console.log('Signed Cookie: ',req.signedCookies);

    //设定cookie中的数据
    res.cookie('cart',{
        item: [1,3,6]
    },{
        maxAge: 20*3600*1000,
        signed: true
    });

    res.cookie('base', 99, {
        maxAge: 2 * 10000
    });

    res.send('Ok');
});
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/2020-02-13_18-59-56.png" alt="" loading="lazy"></figure>
<p><code>res.cookie('name','value',options)</code></p>
<p>其中 <code>options</code>要求是要 json 格式：有以下选项</p>
<ul>
<li><strong>domain</strong>: 域名。设置子域名（二级域名）是否可以访问 cookie。 例：<code>domain:'. 主域名' name=value：键值对</code>，可以设置要保存的 Key/Value，注意这里的 name 不能和其他属性项的名字一样</li>
<li><strong>expires</strong>： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如<code>expires=Wednesday, 09-Nov-99 23:12:40 GMT</code></li>
<li><strong>maxAge</strong>： 最大失效时间（单位：<code>毫秒</code>），设置在多少后失效</li>
<li><strong>secure</strong>： 当 secure 值为 true 时， cookie 在 HTTP 中是无效，在 <code>HTTPS</code>中才有效</li>
<li><strong>path</strong>： 表示 cookie 影响到的路由，如 <code>path=/</code>。如果路径不能匹配时，浏览器则不发送这个 Cookie</li>
<li><strong>httpOnly</strong>：默认为 false, 建议设置为 true, 客户端将无法通过<code>document.cookie</code>读取到 COOKIE 信息，可防止 <code>XSS 攻击</code>产生</li>
<li><strong>signed</strong>： 表示是否签名（加密） cookie, 设为 true 会对这个 cookie 签名，这样就需要用 <code>res.signedCookies</code> 访问它, 前提需要设置上面中间件 app.use 传参 。未签名则用 <code>res.cookies</code> 访问</li>
<li>被篡改的签名 cookie 会被服务器拒绝，并且 cookie 值会重置为它的原始值</li>
</ul>
<h4 id="cookie-session-网站访问次数统计"><code>cookie-session</code>-网站访问次数统计</h4>
<blockquote>
<p>顾名思义，该中间件是指<code>sessionID</code>存放在<code>cookie</code>中的类型</p>
<p><code>session</code>还可以存放在内存中、<code>redis</code>中等等</p>
<p>时刻注意：<code>session</code>的具体内容是存放到服务器中的，在<code>cookie</code>中存放的仅仅是<code>sessionID</code>而已，并且该中间件自带安全的功能 —— 对<code>sessionID</code>进行签名后存储</p>
</blockquote>
<pre><code class="language-js">//简单的网站访问次数统计
const express = require('express');
const cookieSession = require('cookie-session');

let app = express();
app.listen(8080);

app.use(cookieSession({
    keys: ['abc','123','jjdk'],
    maxAge: 20*60*1000
}));

app.get('/getSession',(req,res)=&gt;{
    // console.log(req.session);
    if (!req.session['mysId']) {
        req.session['mysId'] = 1;
    } else {
        req.session['mysId']++;
    }

    req.session['mount'] = '$199.9';
    
    res.send(`欢迎你第${req.session['mysId']}次访问本站,你的余额为${req.session['mount']}`);
});
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/2020-02-13_19-23-34.png" alt="" loading="lazy"></figure>
<h2 id="510-框架-koa">5.10 框架-KOA</h2>
<blockquote>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/weixin_34029949/article/details/88216712">1.koa常用API</a>，[常用中间件介绍](E:\笔记\Node.js\参考资料\Koa 、Koa-router 常用 API_mjzhang1993 的博客 - CSDN 博客.md)</p>
<p><a href="https://koa.bootcss.com/#">2.koa官方文档</a></p>
<p><a href="https://www.itying.com/koa/article-index-id-90.html">3.koa实例教程</a></p>
</blockquote>
<h3 id="5101-基本介绍">5.10.1 基本介绍</h3>
<blockquote>
<p><code>koa</code>分为三个版本，但是由于<code>v3</code>迟迟未曾发布，因此我们仍然使用的是<code>v2-v3</code>的过渡版本</p>
<p>其中异步操作的处理仍然是使用<code>async/await</code>进行转化书写</p>
</blockquote>
<h4 id="ctx上下文对象"><code>ctx</code>上下文对象</h4>
<blockquote>
<p><code>Koa Context</code> 将 node 的 request 和 response 对象封装到单个对象中，为编写程序提供了许多有用的方法，这些操作在 HTTP 服务器开发中频繁使用，没给请求都将创建一个 Context，并在中间件中作为接收器引用，或者 ctx 参数</p>
</blockquote>
<pre><code class="language-js">//ctx.req Node 的 request 对象
//ctx.res Node 的 response 对象 绕过 Koa 的 response 处理是不被支持的

//ctx.request Koa 的 Request 对象
//ctx.response koa 的 Response 对象

//ctx.app 应用程序实例引用
//ctx.state 用于存储一些数据，一些中间件会默认将这里的属性作为 模板渲染的上下文

//ctx.ip  客户端的ip地址

//ctx.cookies.get(name, [options]) 获取名为 name 的 cookie ; options 是参数
//ctx.cookies.set(name, value, [options]) 设置 名为 name 的 cookie 值为 value； options 中的参数，包括签名等

//ctx.throw([status], [msg], [properties]) 用来抛出错误 status 抛出错误的状态码，msg 描述信息, properties 可以设置 error 的其他属性

//ctx.respond 设置为 false 可以绕过 Koa 内置的 response 处理，写入原始的 res 对象而不是让 Koa 处理 response
</code></pre>
<h4 id="servercontext"><code>server.context</code></h4>
<blockquote>
<p>是<code>ctx</code>对象的原型对象，我们可以向其中加入属性或方法，这样我们就能够在全局范围内通过<code>ctx.Property/Function</code>的形式来使用</p>
<blockquote>
<p>应用创建的 ctx 的原型，可以在其上添加其他属性，这样整个应用的 ctx 都可以使用这些属性</p>
</blockquote>
</blockquote>
<pre><code class="language-js">const Koa = require('koa');
const Router = require('koa-router');
const chalk = require('chalk');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

let router = new Router();

app.context.show = ()=&gt;{
    console.log('abc');
};

router.get('/a',async ctx=&gt;{
    ctx.show();

    ctx.body += 'Done';
});

app.use(router.routes());
</code></pre>
<h4 id="throw-assert"><code>throw &amp; assert</code></h4>
<blockquote>
<p>都可以用来对错误的代码进行抛出处理并自动退出代码的运行</p>
<p>使用方法：</p>
<p>1.<code>ctx.throw([status], [msg], [properties])</code> 用来抛出错误 status 抛出错误的状态码，msg 描述信息, properties 可以设置 error 的其他属性</p>
<p>2.<code>ctx.assert([判断条件],[status], [msg], [properties])</code>，即<code>assert</code>方法就相当于调用了：<code>if(判断条件) ctx.throw()</code></p>
</blockquote>
<pre><code class="language-js">const Koa = require('koa');
const Router = require('koa-router');
const chalk = require('chalk');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.red('Listen at http://localhost:' + 8080));
});

let router = new Router();

/**
 * assert
 */
router.get('/login',async ctx=&gt;{
    ctx.assert(ctx.query.user,400,'username is required');
    ctx.assert(ctx.query.pass,400,'password is required');
});

app.on('error', function (err, ctx) {
    console.log('error Event', err.message, err.abv);
});

app.use(router.routes());

/**
 * throw
 */
app.use(async ctx=&gt;{
    ctx.throw(401, 'something wrong', {abv: 'this is user'});
});

</code></pre>
<h3 id="5102-中间件">5.10.2 中间件</h3>
<h4 id="路由koa-router">路由<code>koa-router</code></h4>
<blockquote>
<p><code>koa</code>不同于<code>express</code>，它并不自带路由，需要通过中间件来实现功能</p>
<p>1.使用时记得最后要将总的路由对象放到页面对象<code>app</code>中：<code>app.use(router.routes())</code></p>
<p>2.同理，在嵌套路由中也要将不同层级的路由放在总路由对象中，当然第一个参数要是访问的路径：<code>router.use('/user',userRouter.routes())</code></p>
<p>**注意：**路径可以接受正则表达式和字符串</p>
</blockquote>
<h5 id="基本使用">基本使用</h5>
<pre><code class="language-js">const Koa = require('koa');
const Router = require('koa-router');
const chalk = require('chalk');

let app = new Koa();
app.listen(8080,()=&gt;{
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

let router = new Router();

router.get('/reg',async (ctx,next)=&gt;{
    console.log(chalk.blueBright('In admin'));
    ctx.body = 'In admin';
    //注意next也要使用await
    await next();
});

//use用来加载中间件
app.use(router.routes());
app.use(router.allowedMethods());

</code></pre>
<img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/8.png" style="zoom: 80%;" />
<h5 id="嵌套路由">嵌套路由</h5>
<blockquote>
<p>适用于大型开发，此时就可以将不同级别的路由分支放在不同的文件中，以方便进行管理</p>
</blockquote>
<pre><code class="language-js">const Koa = require('koa');
const Router = require('koa-router');
const chalk = require('chalk');

let app = new Koa();
app.listen(8080,()=&gt;{
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

let router = new Router();

/**
 * 设置user一级的路由
 */
let userRouter = new Router();

let company = new Router();
company.get('/a',async ctx=&gt;{
    console.log(chalk.yellow('company-a'));
    
    ctx.body = 'company.a';
})

let admin = new Router();
admin.get('/a',async ctx=&gt;{
    console.log(chalk.green('admin-a'));
    
    ctx.body = 'admin.a';
});

//访问根目录时
userRouter.get('/',async ctx=&gt;{
    console.log(chalk.blueBright('user'));
    
    ctx.body = 'USER';
});

userRouter.use('/company',company.routes());
userRouter.use('/admin',admin.routes());


/**
 * 设定其他的路由
 */
let newsRouter = new Router();
let cartRouter = new Router();

router.use('/user',userRouter.routes());
router.use('/news',userRouter.routes());
router.use('/user',userRouter.routes());

app.use(router.routes());

</code></pre>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/6.png" alt="" loading="lazy"></figure>
<h5 id="动态路由">动态路由</h5>
<blockquote>
<p>通过在<code>url</code>中设置<code>:VAR</code>的形式来设置动态的路由，这个参数的值放在JSON<code>ctx.params</code>中</p>
</blockquote>
<pre><code class="language-js">const Koa = require('koa');
const Router = require('koa-router');
const chalk = require('chalk');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

let router = new Router();

router.get('/news/:id/', async ctx =&gt; {

    console.log(ctx.params);
    let {
        id
    } = ctx.params;

    ctx.body = 'News: ' + id;
});


router.get('/news/:id1/:id2/:id3', async ctx =&gt; {
    let {
        id1,
        id2,
        id3
    } = ctx.params;

    ctx.body = `News: ${id1}, ${id2}, ${id3}`;
});

app.use(router.routes());
</code></pre>
<ul>
<li>引申问题：该方法与<code>query</code>传入参数的形式有何优势、劣势？</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/9.png" alt="" loading="lazy"></figure>
<h4 id="static-2"><code>static</code></h4>
<blockquote>
<p>需要第三方下载的中间件，是用于处理客户端访问静态资源的请求的</p>
<p>使用中有两个属性值得注意：</p>
<p>1.最大缓存时间：<code>maxAge</code></p>
<p>2.默认文件：<code>index</code>，指的是访问根目录时其会返回的默认文件</p>
</blockquote>
<pre><code class="language-js">const Koa = require('koa');
const Router = require('koa-router');
const chalk = require('chalk');
const static = require('koa-static');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

let router = new Router();

router.get('/user',async ctx=&gt;{
    ctx.body = 'USER';
});

app.use(router.routes());

app.use(static('./static',{
    //最大缓存时间
    maxAge: 20*60*1000,
    //设置默认文件
    index: './static/1.html'
}));
</code></pre>
<pre><code class="language-js">/**
* 针对不同的文件格式，设置不同的过期时间
*/
const Koa = require('koa');
const Router = require('koa-router');
const chalk = require('chalk');
const static = require('koa-static');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

let router = new Router();

//路径可以接受正则表达式
router.get(/(\.jpg|\.png|\.gif)$/i, static('./static', {
    maxAge: 7 * 86400 * 1000
}));

router.get(/(\.css)$/i, static('./static', {
    maxAge: 30 * 86400 * 1000
}));

router.get(/(\.html|\.shtml|\.htm)$/i, static('./static', {
    maxAge: 365 * 86400 * 1000
}));

//剩余的请求,*其实代表所有的请求，而''空字符串代表根目录
router.get('*', static('./static', {
    maxAge: 20 * 86400 * 1000
}));

app.use(router.routes());
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/13-2.png" alt="" loading="lazy"></figure>
<h4 id="koa-better-body"><code>koa-better-body</code></h4>
<blockquote>
<p>十分好用，能够处理<code>post &amp; File</code>数据</p>
</blockquote>
<pre><code class="language-js">const koa = require('koa');
const Router = require('koa-router');
const body = require('koa-better-body');
const chalk = require('chalk');

let app = new koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

app.use(body({
    uploadDir: './upload'
}));

/**
 * 该中间件对于文件和post数据均能够处理
 */
app.use(async ctx=&gt;{
    console.log(ctx.request.fields);
    
    ctx.body = 'Done';
});
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/14-2.png" alt="" loading="lazy"></figure>
<h4 id="cookie-2"><code>Cookie</code></h4>
<blockquote>
<p>该中间件是<code>KOA</code>自带的，它包含有两个函数</p>
<p><code>ctx.cookies.get(name, [options])</code>获取名为 name 的 cookie ; options 是参数<br>
<code>ctx.cookies.set(name, value, [options])</code>设置 名为 name 的 cookie 值为 value； options 中的参数，包括签名等</p>
<p>**注意：**为了保证用户恶意修改<code>cookie</code>中的值，因此在获取和设置的时候都要加上<code>signed:true</code></p>
</blockquote>
<pre><code class="language-json">//[options]的值
{
maxAge         : 一个数字表示从 Date.now() 得到的毫秒数
expires cookie : 过期的 Date
path cookie    : 路径, 默认是'/'
domain cookie  : 域名
secure        : 安全 cookie   默认false，设置成true表示只有 https可以访问
httpOnly      : 是否只是服务器可访问 cookie, 默认是 true
overwrite     : 一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（不管路径或域）是否在设置此Cookie 时从 Set-Cookie 标头中过滤掉。
}
</code></pre>
<pre><code class="language-js">const Koa = require('koa');
const chalk = require('chalk');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

app.keys = [
    'abcjinosngoege',
    'osidnageogeooe',
    'spopeowgnllnvd'
];

app.use(async ctx=&gt;{
    // ctx.cookies.set('user','richardTao',{
    //     maxAge: 20*86400*1000,
    //     signed: true
    // });

    //为保证了cookie的有效性，在获取和设置的时候都要加上'signed'
    console.log(ctx.cookies.get('user',{
        signed: true
    }));
    
    ctx.body = 'Cookie Get Done';
});
</code></pre>
<h4 id="koa-session"><code>koa-session</code></h4>
<blockquote>
<p><code>session</code>的使用必须是经过数字签名的——即<code>app.keys</code>不能缺少；</p>
<p>并且，在使用该中间件时，还需要传入app实例，目的是得到<code>keys</code></p>
</blockquote>
<pre><code class="language-js">const Koa = require('koa');
const chalk = require('chalk');
const session = require('koa-session');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

app.keys = [
    'abcjinosngoege',
    'osidnageogeooe',
    'spopeowgnllnvd'
];

/**
 * 在使用该中间件时，记得要传入app实例，目的是得到keys
 */
app.use(session({
    maxAge: 20 * 60 * 1000, //有效期
    renew: true //自动续期 
}, app));

app.use(async ctx =&gt; {
    if (!ctx.session['view']) {
        ctx.session['view'] = 0;
    }
    ctx.session['view']++;

    ctx.body = `Welcome user, you have view this site ${ctx.session['view']} per \n`;

    ctx.body += 'Done';
});
</code></pre>
<h4 id="数据库"><code>数据库</code></h4>
<blockquote>
<p>数据库的操作与之前大体相同，只是我们通常会将包装后的<code>db</code>添加到上下文对象的原型对象中，这样在全体应用中我们都可以使用</p>
</blockquote>
<pre><code class="language-js">const Koa = require('koa');
const chalk = require('chalk');
const Router = require('koa-router');
const mysql = require('mysql');
const co = require('co-mysql');

let app = new Koa();
app.listen(8080, () =&gt; {
    console.log(chalk.yellow('Listen at http://localhost:' + 8080));
});

let conn = mysql.createPool({
    host: 'localhost',
    port: '3306',
    user: 'root',
    password: '123456',
    database: 'learn'
});
let db = co(conn);

/**
 * 将db对象添加到ctx中，以便于整个应用可以使用
 */
app.context.db = db;

/**
 * 在所有的请求之前捕获异步操作的错误
 * 如果下面的方法中没有捕获错误则使用该方法，
 * 否则就由其自定义的try...catch去处理
 */
app.use(async (ctx,next)=&gt;{
    try {
        //如果没有错误则继续向下执行
        await next();
    } catch (error) {
        ctx.body = 'Something Wrong';
    }
});


app.use(async ctx =&gt; {
    try {
        let data = await ctx.db.query('select * fom items');
        ctx.body = data;
    } catch (error) {
        ctx.throw(500, 'Database Error');
    }
});
</code></pre>
<img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/17-3.png" style="zoom:67%;" />
<p>同理，在<code>router</code>中我们也可以这样去处理错误：</p>
<img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/17-4.png" style="zoom:67%;" />
<h3 id="5103-服务器渲染">5.10.3 服务器渲染</h3>
<h4 id="渲染概念">渲染概念</h4>
<blockquote>
<p>渲染分为两种：服务器渲染 以及 客户端渲染</p>
</blockquote>
<ul>
<li>服务端渲染
<ul>
<li>主要使用框架：<code>pug &amp; ejs</code></li>
<li>优势：1.安全性； 2.利于SEO</li>
</ul>
</li>
<li>客户端渲染
<ul>
<li>主要使用框架：<code>vue &amp; react</code></li>
<li>优势：1.节约流量； 2.用户体验好-因为不用刷新页面就可渲染完成</li>
</ul>
</li>
</ul>
<h4 id="pug"><code>pug</code></h4>
<blockquote>
<p>主要是使用缩进作为层级的标志</p>
<p><a href="https://pugjs.org/zh-cn/api/getting-started.html">官方文档</a></p>
</blockquote>
<img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/3.png" style="zoom:67%;" />
<h4 id="ejs-更常用"><code>ejs</code>-更常用</h4>
<blockquote>
<p><a href="https://ejs.bootcss.com/#docs">官方文档</a></p>
</blockquote>
<img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/5-1.png" style="zoom:67%;" />
<ul>
<li>设置的属性参考：</li>
</ul>
<img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/ejs.png" style="zoom:67%;" />
<h2 id="511-综合项目">5.11 综合项目</h2>
<blockquote>
<p><a href="E:%5CCode%5CJS%5CKOA_Server">项目</a>功能完成的是一个博客管理系统，但是功能还未全部实现</p>
<p>目前后台功能基本落实，需要完善页面的美化</p>
<p>前台的文章、轮播图、主题功能完成，搜索等功能还未实现</p>
</blockquote>
<h3 id="5111-补充分页功能">5.11.1 补充：分页功能</h3>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/2020-03-06_20-50-00.png" alt="" loading="lazy"></figure>
<ul>
<li>在<code>router</code>的末尾加上<code>page=?</code>的请求</li>
<li>使用<code>sql</code>语句的拼接，利用<code>limit</code>来进行分页</li>
</ul>
<h1 id="6打包工具">6.打包工具</h1>
<h2 id="61-gulp">6.1 <code>gulp</code></h2>
<blockquote>
<p><a href="https://lin-xin.gitee.io/article/1/">gulp常用插件用法</a></p>
</blockquote>
<h3 id="611-gulp安装与基本使用">6.1.1 gulp安装与基本使用</h3>
<blockquote>
<p><code>gulp</code>的安装需要两个部分</p>
<p>一是在全局部分需要安装：<code>cnpm i gulp -g</code></p>
<p>二是在工程目录进行安装：<code>cnpm i gulp -D</code></p>
<p><code>gulp</code>在更新到<code>@4.0.2</code>之后语法有所改变,<a href="https://www.jianshu.com/p/c30ff8592421">改变内容</a></p>
<p>在<code>gulp</code>中添加任务，在任务中使用一般思维进行流操作即可完成打包工作</p>
</blockquote>
<pre><code class="language-js">// 在方法中使用流式操作来完成压缩
    /**
     * src: 指定源文件的目录, 由于存在多个文件所以使用数组来包裹
     *  我们要找目录下所有子目录以及根目录文件，就需要使用**来完成
     * pipe: 流操作
     * dest: 指定输出文件的目录
     */
// 添加任务
gulp.task('js', () =&gt; {
return gulp.src('./src/js/**/*.js')
    .pipe(concat('one.min.js'))
    .pipe(uglify())
    .pipe(gulp.dest('./build/js/'));
)};
// 添加默认任务，这是必须要有的
gulp.task('default', gulp.series('js'));
</code></pre>
<h3 id="612-常用插件">6.1.2 常用插件</h3>
<blockquote>
<p>使用插件最好的学习方式就是查看它的官方文档，如<a href="https://www.npmjs.com/">npmjs官网搜索</a></p>
</blockquote>
<pre><code class="language-js">const gulp = require('gulp')
// 用于文件的压缩
const uglify = require('gulp-uglify')
// 用于文件的合并
const concat = require('gulp-concat')
// 用于文件的重命名
const rename = require('gulp-rename')
// 用于支持ES6语法，因为gulp本身不支持，因此由该插件来实现语法的转换
// 但是实际上这里引入的只是babel的适配器，而并非本体
const babel = require('gulp-babel')
// 由于压缩在同一行，下面这个插件可以记录源代码的信息-以方便后续调试
// 分为两个步骤，在编译之前先初始化操作，在各个操作完成之后再写入文件中
// 但是这需要浏览器的支持，一般而言chrome支持较好
const sourcemaps = require('gulp-sourcemaps')
// 压缩css文件
const cssmin = require('gulp-cssmin')
// 用于压缩图片文件，但是基本功能不止于此
const imgmin = require('gulp-imagemin')
// 使得浏览器端能够自动响应服务端文件的变化而刷新页面
// 主要用于和 watch配合来使用
const livereload = require('gulp-livereload')
</code></pre>
<h4 id="gulp-uglify">gulp-uglify</h4>
<blockquote>
<p>功能用于文件的压缩，将文件内容压缩到一行内</p>
</blockquote>
<pre><code class="language-js">return gulp.src('./src/js/**/*.js')
    .pipe(concat('one.min.js'))
    .pipe(uglify())
    .pipe(gulp.dest('./build/js/'));
</code></pre>
<h4 id="gulp-concat">gulp-concat</h4>
<blockquote>
<p>用于文件的合并, 将多个文件的内容合并到同一个文件中,利于大型项目</p>
</blockquote>
<pre><code class="language-js">return gulp.src('./src/js/**/*.js')
    .pipe(concat('one.min.js'))
    .pipe(uglify())
    .pipe(gulp.dest('./build/js/'));
</code></pre>
<h4 id="gulp-rename">gulp-rename</h4>
<blockquote>
<p>常常需要将合并、压缩后的文件进行重命名以区分，这个插件可以做到</p>
</blockquote>
<pre><code class="language-js">return gulp.src('./src/js/**/*.js')
    .pipe(uglify())
    .pipe(rename({suffix: '.min'}))
    .pipe(gulp.dest('./build/js/'));
</code></pre>
<h4 id="gulp-babel">gulp-babel</h4>
<blockquote>
<p>用于支持ES6语法，因为gulp本身不支持，因此由该插件来实现语法的转换，但是实际上这里引入的只是babel的适配器，而并非本体</p>
<p>在使用之前需要安装： <code>cnpm i @babel/core, @babel/preset-env -D</code></p>
</blockquote>
<pre><code class="language-js">return gulp.src('./src/js/**/*.js')
    .pipe(babel({
        presets: ['@babel/env']
    }))
    .pipe(uglify())
    .pipe(rename({suffix: '.min'}))
    .pipe(gulp.dest('./build/js/'));
</code></pre>
<h4 id="gulp-sourcemaps">gulp-sourcemaps</h4>
<blockquote>
<p>在压缩合并之后，原先的<code>js</code>文件将变得难以调试（因为文件都集中在几行中）</p>
<p>该插件可以记录源代码的信息-以方便后续调试。</p>
<p>分为两个步骤：在编译之前先初始化操作，在各个操作完成之后再写入文件中，</p>
<p>但是这需要浏览器的支持，一般而言chrome支持较好</p>
</blockquote>
<pre><code class="language-js">return gulp.src(paths.js.src)
        .pipe(sourcemaps.init())
        .pipe(babel({
            presets: ['@babel/env']
        }))
        .pipe(uglify())
        .pipe(sourcemaps.write())
        .pipe(rename({
            suffix: '.min'
        }))
        .pipe(gulp.dest(paths.js.dest));
</code></pre>
<h4 id="gulp-cssmin">gulp-cssmin</h4>
<blockquote>
<p>用于压缩<code>css</code>文件</p>
</blockquote>
<pre><code class="language-js">gulp.task('style', () =&gt; {
    return gulp.src(paths.style.src)
        .pipe(concat('dev.min.css'))
        .pipe(cssmin())
        .pipe(gulp.dest(paths.style.dest))
});
</code></pre>
<h4 id="gulp-imagemin">gulp-imagemin</h4>
<blockquote>
<p>该插件用于压缩图片文件，但同时可以对<code>gif,png,jpg,svg</code>这几种文件进行优化操作，使得在压缩之后还可以保持原先的图片质量</p>
</blockquote>
<pre><code class="language-js">gulp.task('image', () =&gt; {
    return gulp.src(paths.image.src)
        .pipe(imgmin([
            // 隔行扫描
            imgmin.gifsicle({
                interlaced: true
            }),
            // 渐进式压缩，这一类方法注意查看npm中的描述
            imgmin.mozjpeg({
                progressive: true,
                quality: 75
            }),
            imgmin.optipng({
                optimizationLevel: 5
            })
        ]))
        .pipe(gulp.dest(paths.image.dest))
});
</code></pre>
<h4 id="gulp-watch-gulp-livereload">gulp-watch &amp; gulp-livereload</h4>
<blockquote>
<p><code>gulp-watch</code>：我们使用<code>gulp</code>进行打包往往希望它能够自动地对于文件内容进行打包处理，对于我们在文件中的改动操作能够实时地自动打包。</p>
<p><code>gulp-livereload</code>：该插件能够让浏览器自动加载<code>js</code>文件，以及对于一些文件变化进行<code>自刷新</code>操作，而不需要用户手动地去刷新浏览器。</p>
<p>不过通常需要浏览器插件的支持</p>
</blockquote>
<pre><code class="language-js">gulp.task('js', () =&gt; {
return gulp.src(paths.js.src)
        .pipe(babel({
            presets: ['@babel/env']
        }))
        .pipe(concat('bundle.min.js'))
        .pipe(uglify())
        .pipe(gulp.dest(paths.js.dest))
        .pipe(livereload());
)};
          
// gulp.watch('文件列表', '任务列表');
gulp.task('watch', () =&gt; {
    livereload.listen();

    gulp.watch(paths.js.src, gulp.series('js'));
    gulp.watch([
        './1.html',
        // 可以添加多个需要监视的文件目录
        ...paths.js.src
    ], file =&gt; {
        livereload.changed(file.path);
    });
});

// 添加默认任务，这是必须要有的
gulp.task('default', gulp.series('js', 'watch'));
</code></pre>
<h2 id="62-webpack">6.2 <code>webpack</code></h2>
<h3 id="621-简单介绍">6.2.1 简单介绍</h3>
<blockquote>
<p><code>webpack</code>本质上就是一个打包工具，它的唯一功能就是用于打包</p>
<p><code>loader</code>扩展<code>webpack</code>的功能，有了它，<code>webpack</code>功能大大增强：从只能打包<code>js</code>到可以打包其他各种类型的文件</p>
</blockquote>
<h4 id="export"><code>export</code></h4>
<ul>
<li>
<p>可以导出变量、函数、类等等，只需要在他们之前加上一个 <code>export</code> 关键字</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre><code class="language-js">export let a = 15;

let b = &quot;name&quot;;
let d = 45;

export { b, d };

export function sum(a, b) {
    return a + b;
};

export class {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    showMsg() {
        console.log(name, age);
    }
}

//-最常用
export default 'abb';

// 从另一个模块导出
export * from './mod2';
export {a,b,c} from './mod3';
export {default} from './mod4';
</code></pre>
<h4 id="import"><code>import</code></h4>
<ul>
<li>
<p>导入可以是目标文件中所有的变量、函数等；也可以是按需导入、只选择部分导入</p>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-js">//全部导入
import * as mod1 from './mod1';

//部分导入
import {a,b,d} from './mod1';

//导入默认成员-最常用
import xxx from './mod1';

//模块的代码引入进来，但不引入其中的成员，如css、图片文件
import &quot;1.css&quot;;
import &quot;a.jpg&quot;;

//异步引入,针对的是页面中次要的东西，如广告、抽奖等
//返回值是一个Promise
import(&quot;./mod2&quot;);
</code></pre>
<h3 id="622-多入口与单入口">6.2.2 多入口与单入口</h3>
<blockquote>
<p>多入口：即entry 可以是单个文件，也可以是一个json文件</p>
</blockquote>
<h4 id="注意事项">注意事项</h4>
<ol>
<li>
<p>entry： 声明入口地址</p>
</li>
<li>
<p>output： 输出，必须是一个<code>json</code>；包含有：path为绝对地址，filename为文件名</p>
</li>
<li>
<p>mode： 模式，值包括 <code>none</code>，<code>production</code> 生产模式以及 <code>development</code> 开发模式</p>
<ul>
<li>
<p><code>none</code>表示不压缩，只是对文件进行打包操作哦</p>
</li>
<li>
<p><code>production</code>表示尽量压缩，最大程度上压缩处理</p>
</li>
<li>
<p><code>development</code>表示保留必要的信息以方便后续开发的调试工作</p>
</li>
</ul>
</li>
<li>
<p>所有当前的路径前要加'./'，这是 <code>node.js</code> 中的要求</p>
</li>
<li>
<p><code>module</code>：添加规则, 注意是<code>rules</code>不是rule，可以添加多条，<strong>从上而下执行</strong>，若是有重叠则会覆盖。</p>
<ul>
<li>
<p>有两个值：<code>test</code>以及<code>use</code>，分别表示‘检测’到特定文件就使用该<code>loader</code>, use需要用数组表示</p>
</li>
<li>
<p>use 的加载顺序是<strong>从后往前</strong></p>
</li>
</ul>
</li>
</ol>
<h4 id="单入口格式">单入口格式</h4>
<pre><code class="language-js">module.exports = {
    mode: 'production',
    // node.js要求所有的当前路径要加'./'
    entry: './index.js',
    // output必须是一个JSON对象。path：绝对路径；filename：输出的文件名
    output: {
        path: path.resolve(__dirname, 'build'),
        filename: 'bundle.js'
    }
};
</code></pre>
<h4 id="多入口格式">多入口格式</h4>
<blockquote>
<p>在<code>output</code>中就需要注意，在指定文件名称的时候就应该使用<code>'[name].min.js'</code>的形式，这样就可以将不同模块的文件分开进行打包</p>
</blockquote>
<pre><code class="language-js">module.exports = {
    mode: 'development',
    entry: {
        index: './src/js/1.js',
        admin: './src/js/2.js'
    },
    output: {
        path: path.resolve(__dirname,'build'),
        // 名称使用以下的通配符来生成两个打包的文件
        filename: '[name].min.js'
    }
};
</code></pre>
<h3 id="623-loader">6.2.3 loader</h3>
<blockquote>
<p><code>loader</code>是<code>webpack</code>的核心部分，<code>loader</code>就是将<code>webpack</code>原先处理不了、不认识的语法文件</p>
<p>进行<strong>预处理</strong>转为字符串或是<code>js</code>，将之后处理的结果交给<code>webpack</code>，使得它能够舒服地进行压缩</p>
<p>等后续的操作</p>
</blockquote>
<h4 id="source-map"><code>source-map</code></h4>
<blockquote>
<p>与之前<code>gulp</code>中提到的作用一致，保存源代码的信息，方便后期调试，webpack中将会将其信息保存到一个单独文件中</p>
<p>使用方法很简单，不需要再下载其他的文件，只需在配置文件的末行加上：</p>
<p><code>devtool: 'source-map'</code></p>
</blockquote>
<h4 id="css-loader-style-loader"><code>css-loader &amp; style-loader</code></h4>
<blockquote>
<p><code>css-loader</code>: 只是让<code>webpack</code>不报错，让它称为js的一部分，可以解析css文件，但是页面没有显示</p>
<p><code>style-loader</code>: 让<code>css</code>变为一个<code>html</code>中的<strong>style标签</strong>从而使用到样式</p>
</blockquote>
<pre><code class="language-js">module.exports = {
    mode: 'development',
    entry: './src/js/1.js',
    output: {
        path: path.resolve(__dirname, 'build'),
        filename: 'bundle.min.js'
    },
    module: {
        // 添加规则, 注意是rules不是rule
        // 可以添加多条，从上而下执行，若是有重叠则会覆盖
        rules: [
            {
             // 有两个值，分别表示‘检测’到特定文件就使用该loader, use需要用数组表示
                /**
                 * use 的加载顺序是从后往前
                 * css-loader: 只是让webpack不报错，让它称为js的一部分，
                 *  可以解析css文件，但是页面没有显示
                 * style-loader: 让css变为一个html中的style标签从而使用到样式
                 * postcss-loader: 需要autoprefixer插件的帮助，实现样式的解析，
                 *  并对于特殊的样式要添加前缀以实现浏览器的兼容
                 */
                test: /\.css$/,
                use: ['style-loader', 'css-loader', 'postcss-loader']
            }
        ]
    }
};
</code></pre>
<h4 id="postcss-loader"><code>postcss-loader</code></h4>
<blockquote>
<p><a href="https://www.cnblogs.com/mengfangui/p/8932915.html">参考文档</a></p>
<p>作用：为了兼容各个版本的浏览器，我们在<code>css</code>样式中需要添加一些前缀来实现这一效果，然而这些工作实际有些繁杂且没有技术含量，那么就可以借用这个<code>loader</code>帮助我们。</p>
<p>值得注意的是：该<code>loader</code>并不能够单独工作，而是需要配合<code>autoprefixer</code>插件来使用</p>
</blockquote>
<pre><code class="language-json">//在使用时可以在package.json中加入以下信息
&quot;browserslist&quot;: [
    &quot;defaults&quot;,
    &quot;not ie &lt; 11&quot;,
    &quot;last 2 versions&quot;,
    &quot;&gt; 5%&quot;,
    &quot;iOS 7&quot;,
    &quot;last 3 iOS versions&quot;
  ]
</code></pre>
<h4 id="file-loader-url-loader"><code>file-loader &amp; url-loader</code></h4>
<blockquote>
<p><code>file-loader</code>：对于 file-loader 而言，需要配置use的参数。</p>
<p>作用是读取并输出文件，主要是处理大文件。</p>
<p><code>url-loader</code>实际可以取代 <code>file-loader</code>，但是需要指定<code>limit</code>。</p>
<p>作用：读取并输出<code>base64</code>，主要是处理小文件，但也可替代file-loader（实际上其内部实现就是使用了<code>file-loader</code>的内容）</p>
</blockquote>
<pre><code class="language-js">			{
                test: /\.(gif|png|jpg)$/i,
                // 对于 file-loader 而言，需要配置use的参数
                // 作用：读取并输出文件，主要是处理大文件
                use: {
                    loader: 'file-loader',
                    options: {
                        outputPath: './images'
                    }
                }
            },

            {
                test: /\.(gif|png|jpg)$/i,
                // url-loader 实际可以取代 file-loader，但是需要指定limit
              // 作用：读取并输出base64，主要是处理小文件，但也可替代file-loader
                use: {
                    loader: 'url-loader',
                    options: {
                        outputPath: './images',
                        // 指定1k文件以下的转为base64, 1k以上的仍然作为单独文件
                        limit: 1024
                    }
                }
            }
</code></pre>
<h4 id="less-loader-babel-loader"><code>less-loader &amp; babel-loader</code></h4>
<blockquote>
<p>使用<code>less-loader</code>需要：<code>less,less-loader</code></p>
<p>使用<code>babel-loader</code>注意：</p>
<p>还需要下载<code>@babel/core,@babel/preset-env</code></p>
<p>这两个<code>loader</code>的作用顾名思义，前者用于打包<code>less</code>的文件，而后者则是将<code>ES6</code>的代码转为浏览器兼容的格式</p>
<p><strong>特别注意</strong>：需要使用<code>exclude</code>来去除对<code>node_modules</code>文件夹的扫描，否则工作量太大而且实际也没有那个必要</p>
</blockquote>
<pre><code class="language-js">module.exports = {
    mode: 'development',
    entry: './src/js/1.js',
    output: {
        path: path.resolve(__dirname, 'build'),
        filename: 'bundle.min.js'
    },
    module: {
        rules: [{
            test: /\.css$/,
            use: ['style-loader', 'css-loader', 'postcss-loader']
        },{
            test: /\.(png|gif|jpg)$/i,
            use: {
                loader: 'url-loader',
                options: {
                    outputPath: './images',
                    limit: 1024
                }
            }
        },{
            // 处理less
            test: /\.less$/,
            use: ['style-loader','css-loader','less-loader']
        },{
            // 处理 ES6
            test: /\.jsx?/i,
            // 不要处理的文件
            exclude: /node_modules/,
            use: {
                loader: 'babel-loader',
                options: {
                    presets: ['@babel/preset-env']
                }
            }
        }]
    },
    // 保存源代码的信息，方便后期调试，webpack中将会将其信息保存到一个单独文件中
    devtool: 'source-map',

    
};
</code></pre>
<h4 id="webpack-dev-server"><code>webpack-dev-server</code></h4>
<blockquote>
<p>1.使用需要下载：</p>
<p><code>webpack,webpack-cli,webpack-dev-server</code></p>
<p>2.不能直接启动，而是需要放在<code>scripts</code>中： 添加一行启动脚本<code>&quot;start&quot;: &quot;webpack-dev-server&quot;</code></p>
<p>3.访问时，需要注意路径问题，其默认是以工程的根目录为启动目录</p>
</blockquote>
<h4 id="jest-jest-webpack"><code>jest &amp; jest-webpack</code></h4>
<blockquote>
<p>作用：用来进行函数等的单元测试，代码的正确检测</p>
</blockquote>
<ul>
<li>
<p>需要下载：<code>jest,jest-webpack</code></p>
</li>
<li>
<p><strong>不能直接启动</strong></p>
<p>与<code>dev-server</code>一样，需要在<code>scripts</code>中添加脚本配置</p>
</li>
<li>
<p>在一个单独的<code>js</code>文件中写测试的具体代码：</p>
</li>
</ul>
<pre><code class="language-js">const fab_mod = require('../src/js/3')

/**
 * 1 2 3 4 5 6 7  8
 * 1 1 2 3 5 8 13 21
 */
// 使用jest做单元测试，语法比较简单
test('fab 1~5', () =&gt; {
    expect(fab_mod.fab(1).toBe(1));
    expect(fab_mod.fab(2).toBe(1));
    expect(fab_mod.fab(3).toBe(2));
    expect(fab_mod.fab(4).toBe(3));
    expect(fab_mod.fab(5).toBe(5));
});

test('fab 7', () =&gt; {
    expect(fab_mod.fab(7).toBe(13));
});


</code></pre>
<h4 id="eslint"><code>eslint</code></h4>
<blockquote>
<p>作用：代码的规范化</p>
</blockquote>
<ul>
<li>
<p>需要下载：<code>eslint,eslint-loader</code></p>
</li>
<li>
<p>使用<code>.eslintrc</code>的<code>json</code>文件配置规则</p>
</li>
</ul>
<pre><code class="language-json">{
    &quot;parserOptions&quot;: {
        &quot;ecmaVersion&quot;: 6,
        &quot;sourceType&quot;: &quot;module&quot;,
        &quot;ecmaFeatures&quot;: {
            &quot;jsx&quot;: true
        }
    },
    // 以下添加自定义的规则
    &quot;rules&quot;: {
        // &quot;indent&quot;: [
        //     &quot;error&quot;,
        //     2
        // ],
        // &quot;linebreak-style&quot;: [
        //     &quot;error&quot;,
        //     &quot;windows&quot;
        // ],
        // &quot;quotes&quot;: [
        //     &quot;error&quot;,
        //     &quot;double&quot;
        // ],
        // &quot;semi&quot;: [
        //     &quot;error&quot;,
        //     &quot;always&quot;
        // ]
    }
}
</code></pre>
<ul>
<li>在<code>webpack.config.json</code>中进行配置</li>
</ul>
<pre><code class="language-js">module.exports = {
    mode: 'development',
    entry: './src/js/1.js',
    output: {
        path: path.resolve(__dirname, 'build'),
        filename: 'bundle.min.js'
    },
    module: {
        rules: [{
            test: /\.jsx?/i,
            exclude: /node_modules/,
            use: {
                loader: 'eslint-loader',

            }
        }]
    },
    devtool: 'source-map',
};
</code></pre>
<h1 id="7-vue">7. Vue</h1>
<blockquote>
<p>生命周期</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/lifecycle.png" alt="生命周期" loading="lazy"></figure>
<h2 id="71-基本概念">7.1 基本概念</h2>
<blockquote>
<p><code>vue</code>的核心是<strong>数据</strong>，使得程序员能够专注于处理数据，而不是表现层的繁杂工作</p>
<p>现代开发模式： <code>vue &amp; react</code>，表现层的工作占20%</p>
<p>传统开发模式： <code>jquery</code>，大部分的时间都花在表现层的处理上</p>
</blockquote>
<ul>
<li><code>MVC</code></li>
<li><code>MVP</code></li>
<li><code>MV-VM</code></li>
</ul>
<h2 id="72-语法">7.2 语法</h2>
<h3 id="721-重要内容">7.2.1 重要内容</h3>
<ol>
<li>
<p><strong>数据同步</strong></p>
</li>
<li>
<p><strong>双向绑定</strong></p>
</li>
<li>
<p><strong>虚拟DOM</strong>：主要特点有</p>
<ul>
<li><code>合并请求</code>（将多个请求集中之后再一次性进行处理），</li>
<li><code>快速查询</code>（虚拟DOM是将原页面节点以<code>json</code>格式保存下来，对于普通的查询请求则不再去请求原始的<code>dom</code>，而是直接从<code>json</code>中获取，性能大大提升）</li>
<li><code>局部刷新</code>（通过<code>key</code>属性判断与原始<code>dom</code>相比哪些节点在本次操作中改变了，那么就只是对这些进行更新）</li>
</ul>
</li>
</ol>
<p>通过以上几个操作，尽量减少了原生<code>dom</code>的操作频率，提高了性能效率</p>
<h4 id="数据同步">数据同步</h4>
<blockquote>
<p>实际上就是通过<code>Proxy</code>这个特性完成真实数据与外部操作的中介，一个形象化的比喻是这类数据角色为<strong>保安</strong>。</p>
<p>每次需要访问、修改真实数据时，需要保安的通报之后才能够完成，那么在保安的处理中对数据的改变进行渲染同步处理，就达到我们的目的</p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;数据同步——完成Vue的部分功能&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;ele1&quot;&gt;
        Name: {{name}}&lt;br&gt;
        Age : {{age}}
    &lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    let el = document.querySelector('#ele1');
    // 存储原来的dom结构
    let template = el.innerHTML;
    // console.log(typeof template);

    // 存储的是真实的数据 
    let _data = {
        name: 'richard',
        age: 18
    };

    // 在改变之前需要调用一次
    render();

    // 代理数据，Vue实际也是一个代理
    let data = new Proxy(_data, {
        // 有set方法以及get方法，其作用顾名思义
        set(obj, name, value) {
            obj[name] = value;

            // console.log('数据改变');
            render();
        }
    });

    // 通过控制台中赋值来验证
    function render() {
        // 改变原有的属性的值
        el.innerHTML = template.replace(/\{\{\w+\}\}/g, str =&gt; {
            // 从表达式中取出具体的属性名
            str = str.substring(2, str.length - 2);
            return _data[str];
        });
    };
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
<h4 id="双向绑定">双向绑定</h4>
<blockquote>
<p>同样还是在<code>render</code>这一渲染方法中进行操作，针对有需要绑定的属性过滤出来后进行单独的处理操作。</p>
</blockquote>
<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;双向绑定——完成Vue的部分功能&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;ele1&quot;&gt;
        InputName:&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br&gt;
        Name: {{name}}&lt;br&gt;
        Age : {{age}}
    &lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    let el = document.querySelector('#ele1');
    // 存储原来的dom结构
    let template = el.innerHTML;
    // console.log(typeof template);

    // 存储的是真实的数据 
    let _data = {
        name: 'richard',
        age: 18
    };

    // 在改变之前需要调用一次
    render();

    // 代理数据，Vue实际也是一个代理
    let data = new Proxy(_data, {
        // 有set方法以及get方法，其作用顾名思义
        set(obj, name, value) {
            obj[name] = value;

            // console.log('数据改变');
            render();
        }
    });

    // 通过控制台中赋值来验证
    function render() {
        // 改变原有的属性的值
        el.innerHTML = template.replace(/\{\{\w+\}\}/g, str =&gt; {
            // 从表达式中取出具体的属性名
            str = str.substring(2, str.length - 2);
            return _data[str];
        });

        // 找到所有的v-model，实现数据的双向绑定
        Array.from(el.getElementsByTagName('input'))
            .filter(ele =&gt; ele.getAttribute('v-model'))
            .forEach(input =&gt; {
                // 拿到使用v-model进行绑定的具体属性名称
                let model_name = input.getAttribute('v-model');
                // 将输入框中的值改变
                input.value = _data[model_name];

                input.oninput = function () {
                    // 这里注意还是要通过代理数据，不能直接给到原始数据，否则没有执行到render()
                    data[model_name] = this.value;
                };
            });
    };
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
<h3 id="722-基础">7.2.2 基础</h3>
<pre><code class="language-html"> &lt;div id=&quot;box1&quot;&gt;
      &lt;!-- vue表达式，可以写一些简单的语法，但是不推荐这样做，而是放到methods中 --&gt;
        Name: {{name}}&lt;br&gt;
        Age : {{age}}&lt;br&gt;
        Birth: {{calcBirth()}}&lt;br&gt;&lt;br&gt;

     &lt;!-- 指令1：v-bind，用于补充html的属性，即可以在标签内部直接使用表达式输出数据,
            由于使用场景多，因此可以简写为':属性' --&gt;
        &lt;strong v-bind:title=&quot;age+'岁'&quot;&gt;{{name}}&lt;/strong&gt;

        &lt;!-- 几乎所有的属性都能够使用以上的形式，但是有两个比较特殊：class &amp; style
                这两个属性，前者通常使用数组形式表示，后者则是以json形式 --&gt;
        &lt;div :class=&quot;class_arr&quot;&gt;&lt;/div&gt;
        &lt;div :style=&quot;style_json&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
</code></pre>
<pre><code class="language-js">let vm = new Vue({
        // 元素选择，相当于选择器。表示该Vue的作用范围
        el: '#box1',
        // vue的核心，数据部分，对于vue而言数据不论在哪儿修改视图层都会同步改变
        data: {
            name: 'abc',
            age: '123',
            // class_str: 'aaa bc ji kkk',
            class_arr: ['aaa', 'bc', 'jo', 'keo'],
            style_json: {
                width: '200px',
                height: '200px',
                top: '150px',
                background: 'aqua',
            }
        },
        // 对于一些操作比较复杂的，将其包装到方法中以方便调用
        methods: {
            calcBirth() {
                return new Date().getFullYear() - this.age;
            }
        },
    });
</code></pre>
<h4 id="vue表达式">vue表达式</h4>
<blockquote>
<p>vue表达式，可以写一些简单的语法，但是不推荐这样做，而是放到methods中</p>
</blockquote>
<h4 id="指令v-bind">指令<code>v-bind</code></h4>
<blockquote>
<p>用于补充html的属性，即可以在标签内部直接使用表达式输出数据</p>
<p>由于使用场景多，因此可以简写为':属性'</p>
</blockquote>
<p><strong>注意</strong>：几乎所有的属性都能够使用以上的形式，但是有两个比较特殊：<code>class &amp; style</code>，这两个属性，前者通常使用数组形式表示，后者则是以<code>json</code>形式</p>
<pre><code class="language-js">class_arr: ['aaa', 'bc', 'jo', 'keo'],
style_json: {
                width: '200px',
                height: '200px',
                top: '150px',
                background: 'aqua',
            }
</code></pre>
<h4 id="指令v-model">指令<code>v-model</code></h4>
<blockquote>
<p><code>v-model</code>实现数据和<strong>输入组件</strong>(input,select,textarea)的双向绑定，跳过了<code>MVC</code>中的<code>controller</code>层，而使得<code>View</code>层和<code>Model</code>层直接交互，但实际上是<code>Vue</code>在背后完成了这些工作</p>
<p>**注意：**v-model进来的数据都是字符串</p>
</blockquote>
<pre><code class="language-html">&lt;!-- v-model实现数据和输入组件(input,select,textarea)的双向绑定，跳过了MVC
    中的controller层，而使得View层和Model层直接交互，但实际上是Vue在背后完成了这些工作 --&gt;
    &lt;div id=&quot;box1&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;

        &lt;p&gt;
            {{name}}
        &lt;/p&gt;
    &lt;/div&gt;

    &lt;!-- v-model进来的数据都是字符串 --&gt;
    &lt;div id=&quot;box2&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;num1&quot;&gt;+
        &lt;input type=&quot;text&quot; v-model=&quot;num2&quot;&gt;
        = {{parseFloat(num1)+parseFloat(num2)}}
    &lt;/div&gt;
</code></pre>
<pre><code class="language-js">let vm = new Vue({
        el: '#box1',
        data:{
            name: 'richard'
        }
    });

    let vm2 = new Vue({
        el: '#box2',
        data: {
            num1: 0,
            num2: 0
        }
    });
</code></pre>
<h4 id="指令v-html-v-text">指令<code>v-html &amp; v-text</code></h4>
<blockquote>
<ol>
<li>
<p><code>v-text</code> 作用不大，通常使用{{}}就能够解决其大部分功能</p>
</li>
<li>
<p><code>v-html</code>较为常用，相当于原生的<code>inner-html</code>，在需要输出带有标签的字符串的时候就需要使用到</p>
</li>
</ol>
<p>​      但是需要注意进行字符串信息的识别，防止有恶意攻击</p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;V-Text &amp; V-Html&lt;/title&gt;
    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 
        1. v-text 作用不大，通常使用{{}}就能够解决其大部分功能
        2. v-html 较为常用，相当于原生的inner-html，在需要输出带有标签的字符串的时候就需要使用到
            但是需要注意进行字符串信息的识别，防止有恶意攻击
     --&gt;
    &lt;div class=&quot;box1&quot;&gt;
        &lt;div v-text=&quot;article&quot;&gt;

        &lt;/div&gt;

        &lt;div v-html=&quot;article&quot;&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    let vm = new Vue({
        el: '.box1',
        data: {
            article: `&lt;p&gt;个人累积大量财富并不对，那相当于是数百万人的财富，这样累积财富对社会很危险&lt;/p&gt;
            &lt;p&gt;个人累积大量财富并不对，那相当于是数百万人的财富，这样累积财富对社会很危险&lt;/p&gt;
            &lt;p&gt;个人累积大量财富并不对，那相当于是数百万人的财富，这样累积财富对社会很危险&lt;/p&gt;`
        }
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h4 id="指令v-onv-showv-if">指令<code>v-on,v-show,v-if</code></h4>
<ul>
<li>
<p><code>v-on</code></p>
<ul>
<li>事件处理，相当于原生的onxxx</li>
<li>其值最好加上方法的括号。<strong>v-on的简称是@</strong></li>
<li>对于简单的处理逻辑，也可以直接写在html标签内</li>
</ul>
</li>
<li>
<p><code>v-show &amp; v-if</code></p>
<ul>
<li><code>v-show</code>: 控制的是一个标签的样式，即<code>display: none</code></li>
<li><code>v-if</code>： 它则是直接将这个标签从页面中删除掉，在很多场景中需要使用(如表单的<code>input</code>)</li>
</ul>
<p>总的来说，后者使用到的场景更多</p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;V-On&lt;/title&gt;
    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        .box2 {
            width: 100px;
            height: 100px;
            background: olivedrab;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;box1&quot;&gt;
        {{index}}
        &lt;!-- 对于v-on事件，其值最好加上方法的括号。v-on的简称是@ --&gt;
        &lt;!-- &lt;input type=&quot;button&quot; value=&quot;+1&quot; v-on:click=&quot;indexAdd(3)&quot;&gt; --&gt;
        &lt;input type=&quot;button&quot; value=&quot;+1&quot; @click=&quot;indexAdd(3)&quot;&gt;

        &lt;br&gt;&lt;br&gt;
        &lt;!-- 对于简单的处理逻辑，也可以直接写在html标签内，如本例中可以是'flag=!flag' --&gt;
        &lt;input type=&quot;button&quot; value=&quot;Toggle&quot; @click=&quot;toggleBox()&quot;&gt;
        &lt;!-- 
            1. v-show: 控制的是一个标签的样式，即display: none，
            2. v-if： 它则是直接将这个标签从页面中删除掉，在很多场景中需要使用(如表单的input)
         --&gt;
        &lt;div class=&quot;box2&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt;
        &lt;br&gt;
        &lt;div class=&quot;box2&quot; v-if=&quot;flag&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    let vm1 = new Vue({
        el: '#box1',
        data: {
            index: 1,
            flag: true
        },
        methods: {
            indexAdd(n) {
                this.index += n;
            },
            toggleBox() {
                this.flag = !this.flag;
            }
        },
    });
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
<h4 id="指令v-for">指令<code>v-for</code></h4>
<blockquote>
<p>可以循环的元素有：<code>数组、json元素、字符串以及数字</code></p>
</blockquote>
<p><strong>注意</strong>：对于这些元素的输出格式，都是值在前面，下标在后面，</p>
<p>数字有所区别：<code>i in num</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;V-On&lt;/title&gt;
    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        .box2 {
            width: 100px;
            height: 100px;
            background: olivedrab;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;box1&quot;&gt;
        &lt;ul&gt;
            &lt;!-- 
                v-for可以用于循环输出：数组、json元素、字符串以及数字。
                对于这些元素的输出格式，都是值在前面，下标在后面，
                数字有所区别： i in num

                :key——对于规模大的循环而言是必要的，配合vue的虚拟dom提高性能
                1.不能重复
                2.一旦确定后不能改变
             --&gt;
            &lt;li v-for=&quot;(user,index) in users&quot; ::key=&quot;user.id&quot;&gt;
                {{index}}. username: {{user.name}} password: {{user.password}}
            &lt;/li&gt;
        &lt;/ul&gt;

        &lt;ol&gt;
            &lt;li v-for=&quot;(item, index) in style_json&quot;&gt;
                {{index}}: {{item}}
            &lt;/li&gt;
        &lt;/ol&gt;

        &lt;ol&gt;
            &lt;!-- 规定从1开始计数 --&gt;
            &lt;li v-for=&quot;i in 20&quot;&gt;
                {{i}}
            &lt;/li&gt;
        &lt;/ol&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    let vm1 = new Vue({
        el: '#box1',
        data: {
            users: [{
                    id: 1,
                    name: 'richard1',
                    password: '123456'
                },
                {
                    id: 2,
                    name: 'richard2',
                    password: '12345456'
                },
                {
                    id: 4,
                    name: 'richard3',
                    password: '1234563463'
                }
            ],
            style_json: {
                width: '100px',
                height: '200px',
                background: 'red'
            }
        },
        methods: {

        },
    });
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
<h4 id="key"><code>:key</code></h4>
<blockquote>
<p>对于规模大的循环而言是必要的，配合vue的虚拟dom提高性能</p>
<p>1.不能重复</p>
<p>2.一旦确定后不能改变</p>
</blockquote>
<pre><code class="language-html">&lt;ul&gt;
            &lt;!-- 
                v-for可以用于循环输出：数组、json元素、字符串以及数字。
                对于这些元素的输出格式，都是值在前面，下标在后面，
                数字有所区别： i in num

                :key——对于规模大的循环而言是必要的，配合vue的虚拟dom提高性能
                1.不能重复
                2.一旦确定后不能改变
             --&gt;
            &lt;li v-for=&quot;(user,index) in users&quot; :key=&quot;user.id&quot;&gt;
	{{index}}. username: {{user.name}} password: {{user.password}}
            &lt;/li&gt;
        &lt;/ul&gt;
</code></pre>
<h4 id="指令v-prev-clock">指令<code>v-pre,v-clock</code></h4>
<ul>
<li>
<p><code>v-pre</code>：预编译，表示vue不需要解析该范围的代码</p>
<ul>
<li>提高性能</li>
<li>防止不必要的解析</li>
</ul>
</li>
<li>
<p><code>v-clock</code>: 解决js文件阻塞加载的情况</p>
<ul>
<li>官方提供的是这样一个方法：即在编译完成后vue自动去除v-clock，但是<strong>具体的样式等可以自定义</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;不太常用的&lt;/title&gt;
    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        *[v-clock]{
            display: none;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 
        v-pre：预编译，表示vue不需要解析该范围的代码
        1.提高性能
        2.防止不必要的解析
     --&gt;

     &lt;!-- &lt;div v-pre&gt;
         {{aogne}}+{{iegn}}
     &lt;/div&gt; --&gt;

     &lt;!-- 
         v-clock: 解决js文件阻塞加载的情况
         官方提供的是这样一个方法：即在编译完成后vue自动去除v-clock，但是具体的样式
         等可以自定义
      --&gt;
     &lt;div id=&quot;box1&quot; v-cloak&gt;
         {{name}}---{{password}}
     &lt;/div&gt;
&lt;/body&gt;

&lt;script src=&quot;./js/sleep.php&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    let vm = new Vue({
        el: '#box1',
        data:{
            name: 'richard',
            password: '123456'
        }
    });
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="723-进阶">7.2.3 进阶</h3>
<h2 id="73-组件">7.3 组件</h2>
<h1 id="微信小程序">微信小程序</h1>
<ul>
<li>帮助文档</li>
</ul>
<img src="https://raw.githubusercontent.com/RichardTaocong/Images/master/data/2020-02-11_19-44-39.png" style="zoom:50%;" />]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-String]]></title>
        <id>https://richardtaocong.github.io/RichardTao.github.io/post/python-string/</id>
        <link href="https://richardtaocong.github.io/RichardTao.github.io/post/python-string/">
        </link>
        <updated>2020-03-25T10:48:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="字符串的相关方法">字符串的相关方法</h1>
<h2 id="11-判断类型方法">1.1 判断类型方法</h2>
<h3 id="111-基本不需要太多记忆">1.1.1 基本：不需要太多记忆</h3>
<pre><code class="language-python">print('abc'.isalpha())  # 只包含英文字母
print('ABcd22'.isalnum())  # 只包含字母以及数字
print('     \t\n'.isspace())  #只包含空格
print('The World Is Wrong'.istitle())  # 判断是否为标题化的(每个单词的首字母大写)
print('the world'.islower())  # 字符都是小写
print('the world'.isupper())  # 字符都是大写
</code></pre>
<pre><code>True
True
True
True
True
False
</code></pre>
<h3 id="112-三个方法区分">1.1.2 三个方法区分</h3>
<blockquote>
<p>特点：1.都不能判断小数； 2.<code>isdigit()</code>可以判断<code>⑴</code>、<code>\u00b2</code>；  3.<code>isnumeric()</code>在2之上还能够判断中文数字</p>
</blockquote>
<pre><code class="language-python">str1 = '123'
str2 = '\u00b2'
str3 = '一千零一'

print(str1.isdecimal(), str1.isdigit(), str1.isnumeric())
print(str2.isdecimal(), str2.isdigit(), str2.isnumeric())
print(str3.isdecimal(), str3.isdigit(), str3.isnumeric())
</code></pre>
<pre><code>True True True
False True True
False False True
</code></pre>
<h2 id="12-查找和替换方法">1.2 查找和替换方法</h2>
<pre><code class="language-python">str = 'I tell you'
print(str.startswith('I'))   #  string.startswith(str):检查字符串是否是以 str 开头
print(str.endswith('ou')) #  检查字符串是否是以 str 结束,注意是ends
</code></pre>
<pre><code>True
True
</code></pre>
<h3 id="121-查找方法">1.2.1 查找方法</h3>
<blockquote>
<p><code>find(str,start,end)</code>:  检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></p>
</blockquote>
<pre><code class="language-python">str = 'A land where the strong make the rules and weak have to obey'
print(str.find('land',0,len(str)))
</code></pre>
<pre><code>2
</code></pre>
<h3 id="122-替换方法">1.2.2 替换方法</h3>
<blockquote>
<p><code>string.replace(old_str, new_str, num=string.count(old))</code>:   把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</p>
</blockquote>
<blockquote>
<p>注意：  该方法不会修改原有的字符串，而是返回一个新的字符串</p>
</blockquote>
<pre><code class="language-python">str = 'A land where the strong make the rules and weak have to obey'
print(str.replace('e','*',3))
</code></pre>
<pre><code>A land wh*r* th* strong make the rules and weak have to obey
</code></pre>
<pre><code class="language-python"># 易水送别
# [唐] 骆宾王
# 此地别燕丹，壮士发冲冠。
# 昔时人已没，今日水犹寒。

poem_list = ['易水送别','骆宾王','此地别燕丹，','壮士发冲冠。','昔时人已没，','今日水犹寒。']

for poem in poem_list:
    
    print('|%s|' % poem.center(20,&quot; &quot;))   # 居中对齐
</code></pre>
<pre><code>|        易水送别        |
|        骆宾王         |
|       此地别燕丹，       |
|       壮士发冲冠。       |
|       昔时人已没，       |
|       今日水犹寒。       |
</code></pre>
<h3 id="123-分片和合并">1.2.3 分片和合并</h3>
<blockquote>
<p><code>split()</code>:  以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格 <br /><br>
<code>sep.join()</code>:  以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串;  注意：调用函数的是分隔符,形参是要合并的对象; 并且它不改变原有的字符串，会返回一个新的字符串作为结果</p>
</blockquote>
<pre><code class="language-python">str = 'A land where the strong make the rules and weak have to obey'
str = str.split()
print(str)

res = '*'.join(str)
print(res)
</code></pre>
<pre><code>['A', 'land', 'where', 'the', 'strong', 'make', 'the', 'rules', 'and', 'weak', 'have', 'to', 'obey']
A*land*where*the*strong*make*the*rules*and*weak*have*to*obey
</code></pre>
<h3 id="124-切片倒序切片">1.2.4 切片&amp;倒序切片</h3>
<blockquote>
<p><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong></p>
</blockquote>
<p>使用形式：<code>字符串[开始索引:结束索引:步长]</code></p>
<ol>
<li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引, 结束索引)</code> =&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code>
<ul>
<li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li>
</ul>
</li>
<li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li>
</ol>
<ul>
<li>
<ol>
<li>截取从 2 ~ 5 位置 的字符串</li>
</ol>
</li>
<li>
<ol start="2">
<li>截取从 2 ~ <code>末尾</code> 的字符串</li>
</ol>
</li>
<li>
<ol start="3">
<li>截取从 <code>开始</code> ~ 5 位置 的字符串</li>
</ol>
</li>
<li>
<ol start="4">
<li>截取完整的字符串</li>
</ol>
</li>
<li>
<ol start="5">
<li>从开始位置，每隔一个字符截取字符串</li>
</ol>
</li>
<li>
<ol start="6">
<li>从索引 1 开始，每隔一个取一个</li>
</ol>
</li>
<li>
<ol start="7">
<li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li>
</ol>
</li>
<li>
<ol start="8">
<li>截取字符串末尾两个字符</li>
</ol>
</li>
<li>
<ol start="9">
<li>字符串的逆序（面试题）</li>
</ol>
</li>
</ul>
<pre><code class="language-python">str = '0123456789'

# 1.截取从 2 ~ 5 位置 的字符串
print(str[2:6])

# 2. 截取从 2 ~ `末尾` 的字符串
print(str[2:])

# 3. 截取从 `开始` ~ 5 位置 的字符串
print(str[:6])

# 4. 截取完整的字符串
print(str[:])

# 5. 从开始位置，每隔一个字符截取字符串
print(str[::2])

# 6. 从索引 1 开始，每隔一个取一个
print(str[1::2])

# 7. 截取从 2 ~ `末尾 - 1` 的字符串
print(str[2:-1])

# 8. 截取字符串末尾两个字符
print(str[-2:])

# 9. 字符串的逆序（面试题）
print(str[::-1])
</code></pre>
<pre><code>2345
23456789
012345
0123456789
02468
13579
2345678
89
9876543210
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://richardtaocong.github.io/RichardTao.github.io/post/hello-gridea/</id>
        <link href="https://richardtaocong.github.io/RichardTao.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>